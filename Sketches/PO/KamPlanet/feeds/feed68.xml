
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	>

<channel>
	<title>techspot.zzzeek.org</title>
	<atom:link href="http://techspot.zzzeek.org/?feed=rss2" rel="self" type="application/rss+xml" />
	<link>http://techspot.zzzeek.org</link>
	<description>the rare comment from Mike Bayer</description>
	<pubDate>Mon, 09 Jun 2008 02:19:35 +0000</pubDate>
	<generator>http://wordpress.org/?v=2.5.1</generator>
	<language>en</language>
			<item>
		<title>Pycon Wrapup</title>
		<link>http://techspot.zzzeek.org/?p=23</link>
		<comments>http://techspot.zzzeek.org/?p=23#comments</comments>
		<pubDate>Fri, 21 Mar 2008 18:48:30 +0000</pubDate>
		<dc:creator>zzzeek</dc:creator>
		
		<category><![CDATA[SQLAlchemy]]></category>

		<guid isPermaLink="false">http://techspot.zzzeek.org/?p=23</guid>
		<description><![CDATA[Jason and I spent a full eight days in Chicago this year, with a full slate of activities.  While we didn't commit to SQLAlchemy sprints ahead of time (and were therefore not officially rostered), we sprinted the entire time on SA and had picked up two or three folks to sprint with us, as [...]]]></description>
			<content:encoded><![CDATA[<p><a href="http://blog.discorporate.us/">Jason</a> and I spent a full eight days in Chicago this year, with a full slate of activities.  While we didn't commit to SQLAlchemy sprints ahead of time (and were therefore not officially rostered), we sprinted the entire time on SA and had picked up two or three folks to sprint with us, as well as helped with some "parallel" SQLAlchemy-related sprints - next year we'll definitely plan ahead of time so that people can get involved sooner and more explicitly.</p>

<p>Pycon started off for SA with a big full day of tutorials, with the work split up among myself, Jason, and <a href="http://spyced.blogspot.com/">Jonathan</a>.   Jonathan did his beginner tutorial, Jason and I did the advanced (<a href="http://blog.discorporate.us/2008/03/advanced-sqlalchemy-tutorial-pycon-2008/">slides</a>).  The huge winner for this tutorial was the <a href="http://blog.discorporate.us/2008/03/sliderepl-released/">slide runner</a> we came up with ("we" means, I wrote a little 20 line header to page through a Python script one chunk at a time, Jason ran 100 miles further with the idea to turn it into a full blown interactive Python prompt).  Using the runner, everyone in the room could keep hitting "enter" and each chunk of code on the projector would come out on their screen and execute itself, leaving them at a Python prompt where they could further explore the constructs that were just created.  Some people just sat back and watched the code go by, others dug in and answered our exercise questions with it.</p>

<p>Next up was my "SQLAlchemy 0.4 and Beyond" talk (<a href="http://techspot.zzzeek.org/pycon2008/sa04andbeyond.pdf">slides</a>) where my goal was to bring people up to speed on where we're at right now, including where we came from, some of the problems we had, and what we've done about them, then segueing into some deeper examples from the current release and into some of the more interesting projects that are underway.</p>

<p>Onto the sprints.  By the time they started, we had already met with various people and attended a few BOFs as well.  Here's a rundown of everything going on:</p>

<ul>
<li><p><strong>Jython</strong> - Frank Wierzbicki, recently hired by Sun to work full time on <a href="http://www.jython.org">Jython</a>, had presented his Jython <a href="http://us.pycon.org/2008/conference/schedule/event/9/">integration</a> of SQLAlchemy.  Frank and I could not share the same goals more closely; both coming from an "enterprisey" Java background, we are well aware that there's a vast world of Java developers who would flock to Python if a Java-compatible yet Pythonic toolset were available, particularly including an ORM with features comparable to <a href="http://www.hibernate.org">Hibernate</a>.   Jason and Frank met up during the sprints to align their architectural paths, as Jason has been working very hard on a full-blown multi-dialect architecture, which will allow the maximum amount of reuse of dialects among any number of DBAPI connectors.  An example is to use the same MySQL compiler with MySQLDB, JDBC, and pyODBC.  Stub modules which account for the idiosyncrasies of each DBAPI would draw upon the central MySQL functionality.   So with a little more effort that's underway, SQLAlchemy should work fully out of the box on Jython trunk in the very near future.</p></li>
<li><p><strong>Django</strong> - yup, a lot went on with Django and SQLAlchemy this year.  We met with a whole room full of Djangoers who've expressed the ongoing desire for Django to have a tighter integration layer with SQLAlchemy available as an option.  <a href="http://blog.michaeltrier.com/2008/3/21/django-sqlalchemy">Michael Trier</a> spearheaded the effort, showing us some of the work he and his team had already completed with their own django-sqlalchemy layer.  We sat down and shared a lot of notes and ideas, including using the new SQLAlchemy <a href="http://www.sqlalchemy.org/docs/04/plugins.html#plugins_declarative">declarative</a> plugin as a guide for developing their own solution, as well as some strategies for best integrating SQLAlchemy connection/transaction management with Django's own <a href="http://www.djangoproject.com/documentation/transactions/">transaction middleware</a>.  We had an initial mini-sprint during an earlier BOF and then we communicated throughout the main sprints.  Jason has hinted he might give Django a try on an upcoming project which would give us a great chance to give it a test spin and fine tune it.</p></li>
<li><p><strong>Zope</strong> - I was thrilled to spend pretty much the entire sprint alongside <a href="https://launchpad.net/~ct-gocept">Christian Theune</a>, a very experienced developer from whom I sought to learn as much as possible.   His company already uses a SQLAlchemy/Zope integrated application, and he was very interested in the new custom instrumentation branch, which was started to enable Philip Eby to <a href="http://groups.google.com/group/sqlalchemy/browse_thread/thread/0904f14e8e3074b8#">integrate</a> SQLAlchemy with <a href="http://pypi.python.org/pypi/Trellis">Trellis</a>.   Christian worked through the branch, which presents an entirely open-ended way to redefine how SQLAlchemy classes are instrumented (or not), to make it such that all access to the mapped class and its instances, including SQLA's own private attributes, may be mediated through external code, thus allowing his application to use Zope security proxies to broker access to all end-user instances and classes.  At the same time, Christian is also interested in full session rollback capability, something we were already starting to implement, so  we're also finally getting deep into letting SA rollback the internal state of its Session in a clean way, so that rollbacks within transactions or SAVEPOINTs will leave you with a session that remains fully usable without needing to expire its contents.  The comprehensive rollback feature will appear as an option sometime within the 0.4 series and be on by default in 0.5.</p></li>
<li><p><strong>Pylons/Turbogears</strong> - This is of course our main stomping ground.  SQLA sprints took place in the same room as the Pylons TG sprint and there was much beer and margaritas consumed.  Chris Perkins of <a href="http://code.google.com/p/dbsprockets/">DBSprokets</a> fame has signed on with myself and <a href="http://compoundthinking.com/blog/">Mark Ramm</a> to make some progress on the Prentice Hall SQLAlchemy book....but for the impatient there will already be an <a href="http://pythonisito.blogspot.com/2008/03/essential-sqlalchemy-available-on.html">Oreilly</a> book available in June.    </p></li>
</ul>

<p>All in all Pycon was fantastic (I missed the controversial lightning talks), the crowd was great (and much bigger), and I got to meet a whole lot of fans..particularly <a href="http://weblog.lonelylion.com/">Chris McAvoy</a> who's probably the most old school - he was one of the very first Myghty users.  Don't weep for Myghty though, if you use <a href="http://www.pylonshq.com">Pylons</a> with <a href="http://www.makotemplates.org">Mako</a>, they're both direct descendants.</p>
]]></content:encoded>
			<wfw:commentRss>http://techspot.zzzeek.org/?feed=rss2&amp;p=23</wfw:commentRss>
		</item>
		<item>
		<title>SQLAlchemy 0.4 and Beyond Slides</title>
		<link>http://techspot.zzzeek.org/?p=22</link>
		<comments>http://techspot.zzzeek.org/?p=22#comments</comments>
		<pubDate>Sat, 15 Mar 2008 16:50:37 +0000</pubDate>
		<dc:creator>zzzeek</dc:creator>
		
		<category><![CDATA[SQLAlchemy]]></category>

		<guid isPermaLink="false">http://techspot.zzzeek.org/?p=22</guid>
		<description><![CDATA[Continuing the topic of slides, heres the slides from my Pycon '08 talk, SQLAlchemy 0.4 and Beyond.
]]></description>
			<content:encoded><![CDATA[<p>Continuing the topic of slides, heres the slides from my Pycon '08 talk, <a href="pycon2008/sa04andbeyond.pdf">SQLAlchemy 0.4 and Beyond</a>.</p>
]]></content:encoded>
			<wfw:commentRss>http://techspot.zzzeek.org/?feed=rss2&amp;p=22</wfw:commentRss>
		</item>
		<item>
		<title>Advanced SQLAlchemy Slides Available</title>
		<link>http://techspot.zzzeek.org/?p=21</link>
		<comments>http://techspot.zzzeek.org/?p=21#comments</comments>
		<pubDate>Sat, 15 Mar 2008 15:26:17 +0000</pubDate>
		<dc:creator>zzzeek</dc:creator>
		
		<category><![CDATA[SQLAlchemy]]></category>

		<guid isPermaLink="false">http://techspot.zzzeek.org/?p=21</guid>
		<description><![CDATA[Jason has posted the slides and Python scripts from our Advanced SQLAlchemy Tutorial at Pycon 2008.  The tutorial went great, as we gave people a "slide runner" script which let them click through each code example in a customized Python shell - it helped a lot with the flow.    Scripts, handouts [...]]]></description>
			<content:encoded><![CDATA[<p>Jason has posted the slides and Python scripts from our <a href="http://blog.discorporate.us/2008/03/advanced-sqlalchemy-tutorial-pycon-2008/">Advanced SQLAlchemy Tutorial</a> at Pycon 2008.  The tutorial went great, as we gave people a "slide runner" script which let them click through each code example in a customized Python shell - it helped a lot with the flow.    Scripts, handouts and everything else should be in the zip...enjoy !</p>
]]></content:encoded>
			<wfw:commentRss>http://techspot.zzzeek.org/?feed=rss2&amp;p=21</wfw:commentRss>
		</item>
		<item>
		<title>Partitioned Collections in SQLAlchemy</title>
		<link>http://techspot.zzzeek.org/?p=20</link>
		<comments>http://techspot.zzzeek.org/?p=20#comments</comments>
		<pubDate>Sun, 17 Feb 2008 22:10:32 +0000</pubDate>
		<dc:creator>zzzeek</dc:creator>
		
		<category><![CDATA[SQLAlchemy]]></category>

		<guid isPermaLink="false">http://techspot.zzzeek.org/?p=20</guid>
		<description><![CDATA[Jason Kirtland discusses some advanced usage of SQLAlchemy's collections framework: Storing a Dictionary of Lists, which he terms a "Partitioned Collection".    A "collection" in that the ultimate storage is a single series of items, "partitioned" in that each item contains a discriminator of some kind which allows the monolithic collection to be [...]]]></description>
			<content:encoded><![CDATA[<p>Jason Kirtland discusses some advanced usage of SQLAlchemy's collections framework: <a href="http://blog.discorporate.us/2008/02/sqlalchemy-partitioned-collections-1/">Storing a Dictionary of Lists</a>, which he terms a "Partitioned Collection".    A "collection" in that the ultimate storage is a single series of items, "partitioned" in that each item contains a <em>discriminator</em> of some kind which allows the monolithic collection to be further grouped into two levels of collection.  A very detailed introduction to how SQLA approaches collections.</p>
]]></content:encoded>
			<wfw:commentRss>http://techspot.zzzeek.org/?feed=rss2&amp;p=20</wfw:commentRss>
		</item>
		<item>
		<title>Expression Transformations</title>
		<link>http://techspot.zzzeek.org/?p=19</link>
		<comments>http://techspot.zzzeek.org/?p=19#comments</comments>
		<pubDate>Thu, 24 Jan 2008 04:12:14 +0000</pubDate>
		<dc:creator>zzzeek</dc:creator>
		
		<category><![CDATA[SQLAlchemy]]></category>

		<guid isPermaLink="false">http://techspot.zzzeek.org/?p=19</guid>
		<description><![CDATA[While the ORM side of SQLAlchemy is what most of our users focus on, SA has always intended to provide a broader set of tools than just that; referring to it as an "ORM" is like referring to the internet as "the web".  Philosophically we aim to approach issues in a broad, "no-shortcuts" way [...]]]></description>
			<content:encoded><![CDATA[<p>While the ORM side of SQLAlchemy is what most of our users focus on, SA has always intended to provide a broader set of tools than just that; referring to it as an "ORM" is like referring to the internet as "the web".  Philosophically we aim to approach issues in a broad, "no-shortcuts" way that takes a long time to perfect but once it starts hitting the "sweet spot", a lot of capability starts falling out of it for free.  </p>

<p>The expression language and the ORM's way of using it is one such example; the ORM considers everything in terms of SQL expressions which are all ultimately user-defined, and attempts to be as unconstrained as possible while at the same time being as informative as possible about what constraints are unavoidable.  To support this, the expression language supports "transformative" behavior which allow an application, not just SA's ORM but any app, to deal with SQL generation in the abstract.  That is, not just abstracted from the particular syntax of a particular database, but abstracted from the structure of the expressions themselves.  </p>

<p>This is clearly a work in progress with caveats galore, but with each major version of SA the main ideas have become more refined and clear in their intent, starting with some murky implementations early on that could only be used in extremely specific operations, later evolving into core concepts from which most of the ORM's querying ability builds from.   Here I want to introduce three concepts that are now commonplace throughout the SA core.</p>

<h3>Column Correspondence</h3>

<p>This is the ability to relate the columns in one SQL expression to another.  Consider these two expressions; each ultimately select from the same table and return the same results:</p>
<pre class="wp_syntax"><code><span style="color: #993333; font-weight: bold;">SELECT</span> id, name <span style="color: #993333; font-weight: bold;">FROM</span> usertable
&nbsp;
<span style="color: #993333; font-weight: bold;">SELECT</span> ua.uid, ua.uname <span style="color: #993333; font-weight: bold;">FROM</span> <span style="color: #66cc66;">&#40;</span><span style="color: #993333; font-weight: bold;">SELECT</span> id <span style="color: #993333; font-weight: bold;">AS</span> uid, name <span style="color: #993333; font-weight: bold;">AS</span> uname <span style="color: #993333; font-weight: bold;">FROM</span> usertable<span style="color: #66cc66;">&#41;</span> <span style="color: #993333; font-weight: bold;">AS</span> ua</code></pre>

<p>When executed, the <code>cursor.description</code> of each statement contains the names of the result columns.  The first statement will have the names <code>id</code> and <code>name</code>, whereas the second will have the names <code>uid</code> and <code>uname</code>.  Column correspondence allows us to match <code>id</code> to <code>uid</code> and <code>name</code> to <code>uname</code>.  Starting with the table definition and expressions for these two selects:</p>
<pre class="wp_syntax"><code>&gt;&gt;&gt; <span style="color: #0908ce;font-weight:bold;">from</span> sqlalchemy <span style="color: #0908ce;font-weight:bold;">import</span> *
&gt;&gt;&gt; meta = MetaData<span style="color: black;">&#40;</span><span style="color: black;">&#41;</span>
&gt;&gt;&gt; users = Table<span style="color: black;">&#40;</span><span style="color: #E04500;">'usertable'</span>, meta, 
...     <span style="color: black;">Column</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'id'</span>, Integer, primary_key=<span style="color: #6f0005;">True</span><span style="color: black;">&#41;</span>,
...     <span style="color: black;">Column</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'name'</span>, String<span style="color: black;">&#40;</span><span style="color: #E04500;">50</span><span style="color: black;">&#41;</span><span style="color: black;">&#41;</span>,
...     <span style="color: black;">&#41;</span>
&nbsp;
&gt;&gt;&gt; s1 = <span style="color: #dc143c;">select</span><span style="color: black;">&#40;</span><span style="color: black;">&#91;</span>users.<span style="color: black;">c</span>.<span style="color: #6f0005;">id</span>.<span style="color: black;">label</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'uid'</span><span style="color: black;">&#41;</span>, users.<span style="color: black;">c</span>.<span style="color: #6f0005;">id</span>.<span style="color: black;">label</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'uname'</span><span style="color: black;">&#41;</span><span style="color: black;">&#93;</span><span style="color: black;">&#41;</span>
&gt;&gt;&gt; ua = s1.<span style="color: black;">alias</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'ua'</span><span style="color: black;">&#41;</span>
&gt;&gt;&gt; s2 = <span style="color: #dc143c;">select</span><span style="color: black;">&#40;</span><span style="color: black;">&#91;</span>ua.<span style="color: black;">c</span>.<span style="color: black;">uid</span>, ua.<span style="color: black;">c</span>.<span style="color: black;">uname</span><span style="color: black;">&#93;</span><span style="color: black;">&#41;</span></code></pre>

<p>The columns in the two selects can be related to the base table as well as each other using <code>corresponding_column()</code>:</p>
<pre class="wp_syntax"><code>&gt;&gt;&gt; <span style="color: #0908ce;font-weight:bold;">print</span> users.<span style="color: black;">corresponding_column</span><span style="color: black;">&#40;</span>s2.<span style="color: black;">c</span>.<span style="color: black;">uid</span><span style="color: black;">&#41;</span>
usertable.<span style="color: #6f0005;">id</span>
&gt;&gt;&gt; <span style="color: #0908ce;font-weight:bold;">print</span> s2.<span style="color: black;">corresponding_column</span><span style="color: black;">&#40;</span>s1.<span style="color: black;">c</span>.<span style="color: black;">uname</span><span style="color: black;">&#41;</span>
uname</code></pre>

<p>With a so-called "composite" expression that contains multiple SELECT statements, the behavior is a little more intricate, as in the UNION below which takes two different tables and melds them together:</p>
<pre class="wp_syntax"><code><span style="color: #993333; font-weight: bold;">SELECT</span> id <span style="color: #993333; font-weight: bold;">AS</span> uid, name <span style="color: #993333; font-weight: bold;">AS</span> uname <span style="color: #993333; font-weight: bold;">FROM</span> <span style="color: #66cc66;">&#40;</span>
    <span style="color: #993333; font-weight: bold;">SELECT</span> id, name <span style="color: #993333; font-weight: bold;">FROM</span> usertable <span style="color: #993333; font-weight: bold;">WHERE</span> name=<span style="color: #ff0000;">'jack'</span> 
&nbsp;
    <span style="color: #993333; font-weight: bold;">UNION</span> <span style="color: #993333; font-weight: bold;">ALL</span>
&nbsp;
    <span style="color: #993333; font-weight: bold;">SELECT</span> id, email_address <span style="color: #993333; font-weight: bold;">FROM</span> addresses <span style="color: #993333; font-weight: bold;">WHERE</span> id=<span style="color: #ff0000;">12</span>
<span style="color: #66cc66;">&#41;</span></code></pre>

<p>The representation in expression form, adding in the <code>addresses</code> table to start:</p>
<pre class="wp_syntax"><code>&gt;&gt;&gt; addresses = Table<span style="color: black;">&#40;</span><span style="color: #E04500;">'addresses'</span>, meta, 
...     <span style="color: black;">Column</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'id'</span>, Integer, primary_key=<span style="color: #6f0005;">True</span><span style="color: black;">&#41;</span>,
...     <span style="color: black;">Column</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'email_address'</span>, String<span style="color: black;">&#40;</span><span style="color: #E04500;">100</span><span style="color: black;">&#41;</span><span style="color: black;">&#41;</span>,
...     <span style="color: black;">Column</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'user_id'</span>, Integer, ForeignKey<span style="color: black;">&#40;</span><span style="color: #E04500;">'usertable.id'</span><span style="color: black;">&#41;</span><span style="color: black;">&#41;</span><span style="color: black;">&#41;</span>
&nbsp;
&gt;&gt;&gt; s1 = users.<span style="color: #dc143c;">select</span><span style="color: black;">&#40;</span><span style="color: black;">&#41;</span>.<span style="color: black;">where</span><span style="color: black;">&#40;</span>users.<span style="color: black;">c</span>.<span style="color: black;">name</span>==<span style="color: #E04500;">'jack'</span><span style="color: black;">&#41;</span>
&gt;&gt;&gt; s2 = <span style="color: #dc143c;">select</span><span style="color: black;">&#40;</span><span style="color: black;">&#91;</span>addresses.<span style="color: black;">c</span>.<span style="color: #6f0005;">id</span>, addresses.<span style="color: black;">c</span>.<span style="color: black;">email_address</span><span style="color: black;">&#93;</span><span style="color: black;">&#41;</span>.<span style="color: black;">where</span><span style="color: black;">&#40;</span>addresses.<span style="color: black;">c</span>.<span style="color: #6f0005;">id</span>==<span style="color: #E04500;">12</span><span style="color: black;">&#41;</span>
&gt;&gt;&gt; u = union_all<span style="color: black;">&#40;</span>s1, s2<span style="color: black;">&#41;</span>
&gt;&gt;&gt; s3 = <span style="color: #dc143c;">select</span><span style="color: black;">&#40;</span><span style="color: black;">&#91;</span>u.<span style="color: black;">c</span>.<span style="color: #6f0005;">id</span>.<span style="color: black;">label</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'uid'</span><span style="color: black;">&#41;</span>, u.<span style="color: black;">c</span>.<span style="color: black;">name</span>.<span style="color: black;">label</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'uname'</span><span style="color: black;">&#41;</span><span style="color: black;">&#93;</span><span style="color: black;">&#41;</span></code></pre>

<p>Now, what column does <code>s3.c.uid</code> correspond to ?  In the above union, its derived from both <code>users.c.id</code> and <code>addresses.c.id</code> All the paths you'd expect work:</p>
<pre class="wp_syntax"><code>&gt;&gt;&gt; <span style="color: #0908ce;font-weight:bold;">print</span> addresses.<span style="color: black;">corresponding_column</span><span style="color: black;">&#40;</span>s3.<span style="color: black;">c</span>.<span style="color: black;">uid</span><span style="color: black;">&#41;</span>
addresses.<span style="color: #6f0005;">id</span>
&gt;&gt;&gt; <span style="color: #0908ce;font-weight:bold;">print</span> users.<span style="color: black;">corresponding_column</span><span style="color: black;">&#40;</span>s3.<span style="color: black;">c</span>.<span style="color: black;">uid</span><span style="color: black;">&#41;</span>
usertable.<span style="color: #6f0005;">id</span>
&gt;&gt;&gt; <span style="color: #0908ce;font-weight:bold;">print</span> addresses.<span style="color: black;">corresponding_column</span><span style="color: black;">&#40;</span>s3.<span style="color: black;">c</span>.<span style="color: black;">uname</span><span style="color: black;">&#41;</span>
addresses.<span style="color: black;">email_address</span>
&gt;&gt;&gt; <span style="color: #0908ce;font-weight:bold;">print</span> s3.<span style="color: black;">corresponding_column</span><span style="color: black;">&#40;</span>users.<span style="color: black;">c</span>.<span style="color: #6f0005;">id</span><span style="color: black;">&#41;</span>
uid</code></pre>

<p>The <code>corresponding_column()</code> method makes usage of a <code>set</code> associated with every column called <code>proxy_set</code>.  Whenever a column is derived from another, it's given  a collection called <code>proxies</code> which contains the originating column, or in the case of a union, all originators.  <code>proxy_set</code> is then created on-demand and is the union of the current column's <code>proxies</code> collection with the <code>proxies</code> collection of each column in that collection, recursively up to the original column; basically a linked list.  To see if the paths of two columns <code>c1</code> and <code>c2</code> overlap, we check if the intersection of <code>c1.proxy_set</code> and <code>c2.proxy_set</code> is non-empty.  Multiple hits can be resolved by taking the largest intersection.</p>

<p>Column correspondence is used all over the place in SQLAlchemy.  One way it's used is to adapt result rows from one selectable to another.  Suppose we plugged into a test database, and created the standard "adjacency list" table <code>nodes</code>:</p>
<pre class="wp_syntax"><code>&gt;&gt;&gt; meta.<span style="color: black;">bind</span> = create_engine<span style="color: black;">&#40;</span><span style="color: #E04500;">'sqlite://'</span><span style="color: black;">&#41;</span>
&gt;&gt;&gt; nodes = Table<span style="color: black;">&#40;</span><span style="color: #E04500;">'nodes'</span>, meta, 
...     <span style="color: black;">Column</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'node_id'</span>, Integer, primary_key=<span style="color: #6f0005;">True</span><span style="color: black;">&#41;</span>,
...     <span style="color: black;">Column</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'parent_id'</span>, Integer, ForeignKey<span style="color: black;">&#40;</span><span style="color: #E04500;">'nodes.node_id'</span><span style="color: black;">&#41;</span><span style="color: black;">&#41;</span>,
...     <span style="color: black;">Column</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'data'</span>, String<span style="color: black;">&#40;</span><span style="color: #E04500;">50</span><span style="color: black;">&#41;</span><span style="color: black;">&#41;</span><span style="color: black;">&#41;</span>
&gt;&gt;&gt; nodes.<span style="color: black;">create</span><span style="color: black;">&#40;</span><span style="color: black;">&#41;</span></code></pre>

<p>Then, we want to load all nodes, as well as their children and grandchildren, using outer joins.  To join a table to itself requires aliases, such as this SQL:</p>
<pre class="wp_syntax"><code><span style="color: #993333; font-weight: bold;">SELECT</span> nodes.node_id, nodes.parent_id, nodes.data, 
       n2.node_id, n2.parent_id, n2.data,
       n3.node_id, n3.parent_id, n3.data
<span style="color: #993333; font-weight: bold;">FROM</span>
       nodes 
       <span style="color: #993333; font-weight: bold;">LEFT</span> <span style="color: #993333; font-weight: bold;">OUTER</span> <span style="color: #993333; font-weight: bold;">JOIN</span> nodes <span style="color: #993333; font-weight: bold;">AS</span> n2 <span style="color: #993333; font-weight: bold;">ON</span> nodes.node_id=n2.parent_id
       <span style="color: #993333; font-weight: bold;">LEFT</span> <span style="color: #993333; font-weight: bold;">OUTER</span> <span style="color: #993333; font-weight: bold;">JOIN</span> nodes <span style="color: #993333; font-weight: bold;">AS</span> n3 <span style="color: #993333; font-weight: bold;">ON</span> n2.node_id=n3.parent_id</code></pre>

<p>Then suppose we want a function that can print out the attributes of a "node" for us, given a result row.  If we were just selecting three columns, we could do this:</p>
<pre class="wp_syntax"><code>&gt;&gt;&gt; <span style="color: #0908ce;font-weight:bold;">def</span> print_node<span style="color: black;">&#40;</span>row<span style="color: black;">&#41;</span>:
...    <span style="color: #0908ce;font-weight:bold;">print</span> <span style="color: #E04500;">&quot;Id:&quot;</span>, row<span style="color: black;">&#91;</span><span style="color: #E04500;">0</span><span style="color: black;">&#93;</span>, <span style="color: #E04500;">&quot;Parent id:&quot;</span>, row<span style="color: black;">&#91;</span><span style="color: #E04500;">1</span><span style="color: black;">&#93;</span>, <span style="color: #E04500;">&quot;Data:&quot;</span>, row<span style="color: black;">&#91;</span><span style="color: #E04500;">2</span><span style="color: black;">&#93;</span></code></pre>

<p>We can see that approach won't work for our query above, as we need to locate three sets of columns at different positions.  While we could try passing in numerical clues as to where the columns we want are, or rely upon naming schemes, SQLAlchemy most cleanly abstracts away column targeting by allowing you to use the actual <code>Column</code> objects which comprise the expression's "columns" clause.  Building our query as an expression:</p>
<pre class="wp_syntax"><code>&gt;&gt;&gt; n2 = nodes.<span style="color: black;">alias</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'n2'</span><span style="color: black;">&#41;</span>
&gt;&gt;&gt; n3 = nodes.<span style="color: black;">alias</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'n3'</span><span style="color: black;">&#41;</span>
&gt;&gt;&gt; all_nodes = nodes.<span style="color: black;">outerjoin</span><span style="color: black;">&#40;</span>n2, nodes.<span style="color: black;">c</span>.<span style="color: black;">node_id</span>==n2.<span style="color: black;">c</span>.<span style="color: black;">parent_id</span><span style="color: black;">&#41;</span>.\
...     <span style="color: black;">outerjoin</span><span style="color: black;">&#40;</span>n3, n2.<span style="color: black;">c</span>.<span style="color: black;">node_id</span>==n3.<span style="color: black;">c</span>.<span style="color: black;">parent_id</span><span style="color: black;">&#41;</span>.<span style="color: #dc143c;">select</span><span style="color: black;">&#40;</span>use_labels=<span style="color: #6f0005;">True</span><span style="color: black;">&#41;</span></code></pre>

<p>The <code>use_labels</code> sets up unique names for each column, which is a current "implementation detail"; SQLAlchemy targets columns ultimately based on string names, so they need to be unique.  While positional targeting would remove this detail, concerns over free-text expressions which might throw off the column count have so far prevented this switch.</p>

<p>We would want to define our <code>print_node</code> as below, referencing only the <code>node</code> table.  The function has no awareness of the <code>n2</code> and <code>n3</code> alias constructs:</p>
<pre class="wp_syntax"><code>&gt;&gt;&gt; <span style="color: #0908ce;font-weight:bold;">def</span> print_node<span style="color: black;">&#40;</span>row<span style="color: black;">&#41;</span>:
...    <span style="color: #0908ce;font-weight:bold;">print</span> <span style="color: #E04500;">&quot;Id:&quot;</span>, row<span style="color: black;">&#91;</span>nodes.<span style="color: black;">c</span>.<span style="color: black;">node_id</span><span style="color: black;">&#93;</span>, \
...    <span style="color: #E04500;">&quot;Parent id:&quot;</span>, row<span style="color: black;">&#91;</span>nodes.<span style="color: black;">c</span>.<span style="color: black;">parent_id</span><span style="color: black;">&#93;</span>, \
...    <span style="color: #E04500;">&quot;Data:&quot;</span>, row<span style="color: black;">&#91;</span>nodes.<span style="color: black;">c</span>.<span style="color: black;">data</span><span style="color: black;">&#93;</span></code></pre>

<p>To differentiate among columns that correspond to <code>nodes</code>, <code>n2</code>, or <code>n3</code>, SQLAlchemy uses a function built on top of <code>corresponding_column</code> called <code>row_adapter</code>, which returns a callable that can translate a row from one selectable to another.  So usage would look like this:</p>
<pre class="wp_syntax"><code>&gt;&gt;&gt; <span style="color: #0908ce;font-weight:bold;">from</span> sqlalchemy.<span style="color: black;">sql</span>.<span style="color: black;">util</span> <span style="color: #0908ce;font-weight:bold;">import</span> row_adapter
&gt;&gt;&gt; n2_adapter = row_adapter<span style="color: black;">&#40;</span>n2, nodes<span style="color: black;">&#41;</span>
&gt;&gt;&gt; n3_adapter = row_adapter<span style="color: black;">&#40;</span>n3, nodes<span style="color: black;">&#41;</span>
&gt;&gt;&gt; <span style="color: #0908ce;font-weight:bold;">for</span> row <span style="color: #0908ce;font-weight:bold;">in</span> all_nodes.<span style="color: black;">execute</span><span style="color: black;">&#40;</span><span style="color: black;">&#41;</span>:   
...    <span style="color: black;">print_node</span><span style="color: black;">&#40;</span>row<span style="color: black;">&#41;</span>
...    <span style="color: black;">print_node</span><span style="color: black;">&#40;</span>n2_adapter<span style="color: black;">&#40;</span>row<span style="color: black;">&#41;</span><span style="color: black;">&#41;</span>
...    <span style="color: black;">print_node</span><span style="color: black;">&#40;</span>n3_adapter<span style="color: black;">&#40;</span>row<span style="color: black;">&#41;</span><span style="color: black;">&#41;</span></code></pre>

<p><code>print_node</code> is used three times with the same row, each time given a different interpretation of that row provided by the adapter.  What <code>row_adapter()</code> does here is provide a decoupling layer between code which knows how a selectable was constructed and code which consumes result rows from that selectable.  </p>

<p>A more wacky example.  Suppose we have a regular mapping between <code>User</code> and <code>Address</code>, with a one-to-many <code>addresses</code> matched by a many-to-one <code>users</code>.  This is the same example in the SQLAlchemy ORM tutorial and dozens of unit tests:</p>
<pre class="wp_syntax"><code>&gt;&gt;&gt; <span style="color: #0908ce;font-weight:bold;">from</span> sqlalchemy.<span style="color: black;">orm</span> <span style="color: #0908ce;font-weight:bold;">import</span> *
&gt;&gt;&gt; <span style="color: #0908ce;font-weight:bold;">class</span> User<span style="color: black;">&#40;</span><span style="color: #6f0005;">object</span><span style="color: black;">&#41;</span>:<span style="color: #0908ce;font-weight:bold;">pass</span>
&gt;&gt;&gt; <span style="color: #0908ce;font-weight:bold;">class</span> Address<span style="color: black;">&#40;</span><span style="color: #6f0005;">object</span><span style="color: black;">&#41;</span>:<span style="color: #0908ce;font-weight:bold;">pass</span>
&gt;&gt;&gt; mapper<span style="color: black;">&#40;</span>User, users, properties=<span style="color: black;">&#123;</span><span style="color: #E04500;">'addresses'</span>:relation<span style="color: black;">&#40;</span>Address, backref=<span style="color: #E04500;">'user'</span><span style="color: black;">&#41;</span><span style="color: black;">&#125;</span><span style="color: black;">&#41;</span>
&gt;&gt;&gt; mapper<span style="color: black;">&#40;</span>Address, addresses<span style="color: black;">&#41;</span></code></pre>

<p>So the DBAs send you a large UNION query that returns for you one address record per user id represented in the addresses table; either the address row that has the domain "@blooger.biz", or if no such address exists for that user, the address row with the highest primary key value.  The query below accomplishes this by selecting first all the "blooger.biz" rows, then unioning that result with the "max id" result which explicitly omits the "blogger.biz" rows: </p>
<pre class="wp_syntax"><code><span style="color: #993333; font-weight: bold;">SELECT</span> addresses.id, addresses.user_id, addresses.email_address
<span style="color: #993333; font-weight: bold;">FROM</span> addresses <span style="color: #993333; font-weight: bold;">WHERE</span>
addresses.email_address.<span style="color: #993333; font-weight: bold;">LIKE</span><span style="color: #66cc66;">&#40;</span><span style="color: #ff0000;">'%@blooger.biz'</span><span style="color: #66cc66;">&#41;</span> 
&nbsp;
<span style="color: #993333; font-weight: bold;">UNION</span> <span style="color: #993333; font-weight: bold;">ALL</span>
&nbsp;
<span style="color: #993333; font-weight: bold;">SELECT</span> addresses.id, addresses.user_id, addresses.email_address
<span style="color: #993333; font-weight: bold;">FROM</span> addresses <span style="color: #993333; font-weight: bold;">JOIN</span>
<span style="color: #66cc66;">&#40;</span><span style="color: #993333; font-weight: bold;">SELECT</span> MAX<span style="color: #66cc66;">&#40;</span>addresses.id<span style="color: #66cc66;">&#41;</span> <span style="color: #993333; font-weight: bold;">AS</span> maxid 
  <span style="color: #993333; font-weight: bold;">FROM</span> addresses <span style="color: #993333; font-weight: bold;">GROUP</span> <span style="color: #993333; font-weight: bold;">BY</span> addresses.user_id<span style="color: #66cc66;">&#41;</span> <span style="color: #993333; font-weight: bold;">AS</span> max_ids
<span style="color: #993333; font-weight: bold;">ON</span> addresses.id=max_ids.maxid
<span style="color: #993333; font-weight: bold;">WHERE</span> <span style="color: #993333; font-weight: bold;">NOT</span> <span style="color: #993333; font-weight: bold;">EXISTS</span><span style="color: #66cc66;">&#40;</span><span style="color: #993333; font-weight: bold;">SELECT</span> <span style="color: #ff0000;">1</span> <span style="color: #993333; font-weight: bold;">FROM</span> addresses <span style="color: #993333; font-weight: bold;">WHERE</span> 
       user_id=addresses.user_id <span style="color: #993333; font-weight: bold;">AND</span> 
       addresses.email_address.<span style="color: #993333; font-weight: bold;">LIKE</span><span style="color: #66cc66;">&#40;</span><span style="color: #ff0000;">'%@blooger.biz'</span><span style="color: #66cc66;">&#41;</span><span style="color: #66cc66;">&#41;</span></code></pre>

<p>How do we "drop in" this select statement into an ORM query with a minimum of headache ?  We could certainly work from the string representation above directly, just say <code>query.from_statement(&lt;text&gt;)</code> and be done with it.  But we're going to want to do more with this query in the next section, where the <code>Query</code> will be able to intelligently manipulate the expression further, so for that we build a SQL construct out of it.  We build such an expression the same way any DBA would design the above SQL directly, working from the inside out:</p>
<pre class="wp_syntax"><code>&gt;&gt;&gt; max_ids = <span style="color: #dc143c;">select</span><span style="color: black;">&#40;</span><span style="color: black;">&#91;</span>func.<span style="color: #6f0005;">max</span><span style="color: black;">&#40;</span>addresses.<span style="color: black;">c</span>.<span style="color: #6f0005;">id</span><span style="color: black;">&#41;</span>.<span style="color: black;">label</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'maxid'</span><span style="color: black;">&#41;</span><span style="color: black;">&#93;</span><span style="color: black;">&#41;</span>.\
...       <span style="color: black;">group_by</span><span style="color: black;">&#40;</span>addresses.<span style="color: black;">c</span>.<span style="color: black;">user_id</span><span style="color: black;">&#41;</span>.<span style="color: black;">alias</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'max_ids'</span><span style="color: black;">&#41;</span>
&gt;&gt;&gt; aalias = addresses.<span style="color: black;">alias</span><span style="color: black;">&#40;</span><span style="color: black;">&#41;</span>
&gt;&gt;&gt; aview = union_all<span style="color: black;">&#40;</span>
...  <span style="color: black;">addresses</span>.<span style="color: #dc143c;">select</span><span style="color: black;">&#40;</span><span style="color: black;">&#41;</span>.<span style="color: black;">where</span><span style="color: black;">&#40;</span>addresses.<span style="color: black;">c</span>.<span style="color: black;">email_address</span>.<span style="color: black;">endswith</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'@blooger.biz'</span><span style="color: black;">&#41;</span><span style="color: black;">&#41;</span>,
...  <span style="color: black;">addresses</span>.<span style="color: #dc143c;">select</span><span style="color: black;">&#40;</span><span style="color: black;">&#41;</span>.\
...    <span style="color: black;">select_from</span><span style="color: black;">&#40;</span>addresses.<span style="color: black;">join</span><span style="color: black;">&#40;</span>max_ids, addresses.<span style="color: black;">c</span>.<span style="color: #6f0005;">id</span>==max_ids.<span style="color: black;">c</span>.<span style="color: black;">maxid</span><span style="color: black;">&#41;</span><span style="color: black;">&#41;</span>.\
...    <span style="color: black;">where</span><span style="color: black;">&#40;</span>
...    ~exists<span style="color: black;">&#40;</span><span style="color: black;">&#91;</span><span style="color: #E04500;">1</span><span style="color: black;">&#93;</span>, and_<span style="color: black;">&#40;</span>
...        <span style="color: black;">addresses</span>.<span style="color: black;">c</span>.<span style="color: black;">user_id</span>==aalias.<span style="color: black;">c</span>.<span style="color: black;">user_id</span>, 
...        <span style="color: black;">aalias</span>.<span style="color: black;">c</span>.<span style="color: black;">email_address</span>.<span style="color: black;">endswith</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'@blooger.biz'</span><span style="color: black;">&#41;</span><span style="color: black;">&#41;</span><span style="color: black;">&#41;</span>
...    <span style="color: black;">&#41;</span>
... <span style="color: black;">&#41;</span></code></pre>

<p>With our statement above, we can drop it into the <code>select_from()</code> method on <code>Query</code>, which is a little bit like <code>from_statement()</code> except the <code>Query</code> will be ready to manipulate the incoming expression as though it were the primary mapped table:</p>
<pre class="wp_syntax"><code>&gt;&gt;&gt; sess = create_session<span style="color: black;">&#40;</span><span style="color: black;">&#41;</span>
&gt;&gt;&gt; sess.<span style="color: black;">query</span><span style="color: black;">&#40;</span>Address<span style="color: black;">&#41;</span>.<span style="color: black;">select_from</span><span style="color: black;">&#40;</span>aview<span style="color: black;">&#41;</span></code></pre>

<p>When the above query fetches rows, the "row adaption" we discussed in the last section is applied to each incoming row, mapping the <code>aview</code> selectable back to the <code>addresses</code> table.  This way, our <code>Address</code> mapper, which still only knows about the <code>addresses</code> table, can target columns against the <code>addresses</code> table when they are in fact adapted from columns targeted against the aliased <code>aview</code> selectable.   In a concrete sense it means that result columns which are labeled (or if we were doing positional column targeting, positioned) corresponding to Column objects present in the <code>aview</code> construct can referenced with Column objects from the <code>addresses</code> table.  When joins and eager loads are added on to this query, its very likely that the same row will be translated using many row adapters at result time, often translating different columns into the same underlying table, as is the case in our <code>nodes</code> example.</p>

<h3>Clause Adaption</h3>

<p>Clause adaption builds upon the idea of <code>corresponding_column()</code> to replace parts of an expression which "correspond" to another expression to that of the other expression.  Originally this operation supported columns only and only worked with simplistic column-oriented expressions, but in recent months it's been expanded to support the replacement of pretty much any kind of expression, and has moved from an outerlying edge case into a core concept which provides the ability to query from "polymorphic" selectables (which select for several different mappers encapsulated in a subquery), to create aliased joins, as well as to allow joins to or from any arbitrary selectable; all generated strictly on the known relationships between the "underlying" tables. </p>

<p>Using our <code>nodes</code> example, we can apply filtering criterion constructed from the <code>nodes</code> table object and apply it towards the aliases of the <code>nodes</code> table.   Such as, to load all nodes who have a grandchild containing the data field "crackers"; the desired SQL is:</p>
<pre class="wp_syntax"><code><span style="color: #993333; font-weight: bold;">SELECT</span> nodes.node_id, nodes.parent_id, nodes.data 
<span style="color: #993333; font-weight: bold;">FROM</span> nodes <span style="color: #993333; font-weight: bold;">JOIN</span> nodes <span style="color: #993333; font-weight: bold;">AS</span> children <span style="color: #993333; font-weight: bold;">ON</span> nodes.node_id=children.parent_id
<span style="color: #993333; font-weight: bold;">JOIN</span> nodes <span style="color: #993333; font-weight: bold;">AS</span> grandchildren <span style="color: #993333; font-weight: bold;">ON</span> children.node_id=grandchildren.parent_id
<span style="color: #993333; font-weight: bold;">WHERE</span> grandchildren.data=<span style="color: #ff0000;">&quot;crackers&quot;</span></code></pre>

<p>If we were given the SQL construct:</p>
<pre class="wp_syntax"><code>&gt;&gt;&gt; children = nodes.<span style="color: black;">alias</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'children'</span><span style="color: black;">&#41;</span>
&gt;&gt;&gt; grandchildren = nodes.<span style="color: black;">alias</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'grandchildren'</span><span style="color: black;">&#41;</span>
&gt;&gt;&gt; n = nodes.<span style="color: #dc143c;">select</span><span style="color: black;">&#40;</span><span style="color: black;">&#41;</span>.\
...     <span style="color: black;">select_from</span><span style="color: black;">&#40;</span>nodes.<span style="color: black;">join</span><span style="color: black;">&#40;</span>children, nodes.<span style="color: black;">c</span>.<span style="color: black;">node_id</span>==children.<span style="color: black;">c</span>.<span style="color: black;">parent_id</span><span style="color: black;">&#41;</span>.\
...     <span style="color: black;">join</span><span style="color: black;">&#40;</span>grandchildren, children.<span style="color: black;">c</span>.<span style="color: black;">node_id</span>==grandchildren.<span style="color: black;">c</span>.<span style="color: black;">parent_id</span><span style="color: black;">&#41;</span><span style="color: black;">&#41;</span></code></pre>

<p>we can apply the criterion <code>nodes.c.data=='crackers'</code>, constructed without knowledge of the <code>grandchildren</code> alias, to that alias using adaption:</p>
<pre class="wp_syntax"><code>&gt;&gt;&gt; <span style="color: #0908ce;font-weight:bold;">from</span> sqlalchemy.<span style="color: black;">sql</span>.<span style="color: black;">util</span> <span style="color: #0908ce;font-weight:bold;">import</span> ClauseAdapter
&gt;&gt;&gt; criterion = nodes.<span style="color: black;">c</span>.<span style="color: black;">data</span>==<span style="color: #E04500;">'crackers'</span>
&nbsp;
&gt;&gt;&gt; <span style="color: #0908ce;font-weight:bold;">print</span> criterion
nodes.<span style="color: black;">data</span> = :nodes_data
&nbsp;
&gt;&gt;&gt; adapted = ClauseAdapter<span style="color: black;">&#40;</span>grandchildren<span style="color: black;">&#41;</span>.<span style="color: black;">traverse</span><span style="color: black;">&#40;</span>criterion<span style="color: black;">&#41;</span>
&gt;&gt;&gt; <span style="color: #0908ce;font-weight:bold;">print</span> adapted
grandchildren.<span style="color: black;">data</span> = :nodes_data
&nbsp;
&gt;&gt;&gt; <span style="color: #0908ce;font-weight:bold;">print</span> n.<span style="color: black;">where</span><span style="color: black;">&#40;</span>adapted<span style="color: black;">&#41;</span>
SELECT nodes.<span style="color: black;">node_id</span>, nodes.<span style="color: black;">parent_id</span>, nodes.<span style="color: black;">data</span> 
FROM nodes JOIN nodes AS children ON nodes.<span style="color: black;">node_id</span> = children.<span style="color: black;">parent_id</span> 
JOIN nodes AS grandchildren ON children.<span style="color: black;">node_id</span> = grandchildren.<span style="color: black;">parent_id</span> 
WHERE grandchildren.<span style="color: black;">data</span> = ?</code></pre>

<p>Above, the <code>ClauseAdapter</code> object is created against the <code>grandchildren</code> alias.  When it's given a clause to <code>traverse()</code>, it produces a copy of that clause with all elements that "correspond" to <code>grandchildren</code> replaced with the corresponding element, in this case the <code>nodes.data</code> column is replaced with <code>grandchildren.data</code>.</p>

<p>The above process is the same thing that happens automatically if you had a mapping setup for <code>nodes</code>, and used aliased joins as follows:</p>
<pre class="wp_syntax"><code>session.<span style="color: black;">query</span><span style="color: black;">&#40;</span>Node<span style="color: black;">&#41;</span>.<span style="color: black;">join</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'children.children'</span>, aliased=<span style="color: #6f0005;">True</span><span style="color: black;">&#41;</span>.\
   <span style="color: #6f0005;">filter</span><span style="color: black;">&#40;</span>Node.<span style="color: black;">data</span>==<span style="color: #E04500;">'crackers'</span><span style="color: black;">&#41;</span></code></pre>

<p>Let's take a look at how adaption applies to our <code>users</code> and <code>addresses</code> example.  Those familiar with SQLAlchemy relations know that the "join condition" between the <code>users</code> and <code>addresses</code> tables is <code>users.c.id==addresses.c.user_id</code>.  When we work with these mappers, anytime SA joins between a <code>User</code> and <code>Address</code> entity, that join condition is all it knows about how these two tables connect.  Since SA never wants to assume things fit into an artificially constrained pattern, we can't "hardcode" to the fact that its really just a primary key/foreign key pair, as it can just as easily be a more complicated user-defined expression.  </p>

<p>Clause adaption comes in when we start issuing joins between selectables which are derived from the base mapped tables. Suppose that when we execute the big addresses query and get back <code>Address</code> objects, we also want to get the <code>User</code> which maps to each address.  We can of course construct this query manually, but we can also <code>join()</code> on the <code>user</code> relation as always, and clause adaption will take care of the fact that we are selecting from a big UNION and not the plain <code>addresses</code> table.  Using <code>compile()</code> on <code>Query</code> to see the generated SQL reveals:</p>
<pre class="wp_syntax"><code>&gt;&gt;&gt; <span style="color: #0908ce;font-weight:bold;">print</span> sess.<span style="color: black;">query</span><span style="color: black;">&#40;</span>Address<span style="color: black;">&#41;</span>.<span style="color: black;">select_from</span><span style="color: black;">&#40;</span>aview<span style="color: black;">&#41;</span>.<span style="color: black;">join</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'user'</span><span style="color: black;">&#41;</span>.<span style="color: black;">add_entity</span><span style="color: black;">&#40;</span>User<span style="color: black;">&#41;</span>.<span style="color: #6f0005;">compile</span><span style="color: black;">&#40;</span><span style="color: black;">&#41;</span>
<span style="color: #993333; font-weight: bold;">SELECT</span> 
    anon_1.id <span style="color: #993333; font-weight: bold;">AS</span> anon_1_id, anon_1.email_address <span style="color: #993333; font-weight: bold;">AS</span> anon_1_email_address, anon_1.user_id <span style="color: #993333; font-weight: bold;">AS</span> anon_1_user_id, 
    usertable.id <span style="color: #993333; font-weight: bold;">AS</span> usertable_id, usertable.name <span style="color: #993333; font-weight: bold;">AS</span> usertable_name 
<span style="color: #993333; font-weight: bold;">FROM</span> 
    <span style="color: #66cc66;">&#40;</span><span style="color: #993333; font-weight: bold;">SELECT</span> addresses.id <span style="color: #993333; font-weight: bold;">AS</span> id, addresses.email_address <span style="color: #993333; font-weight: bold;">AS</span> email_address, addresses.user_id <span style="color: #993333; font-weight: bold;">AS</span> user_id 
    <span style="color: #993333; font-weight: bold;">FROM</span> addresses 
    <span style="color: #993333; font-weight: bold;">WHERE</span> addresses.email_address <span style="color: #993333; font-weight: bold;">LIKE</span> ? 
&nbsp;
    <span style="color: #993333; font-weight: bold;">UNION</span> <span style="color: #993333; font-weight: bold;">ALL</span> 
&nbsp;
    <span style="color: #993333; font-weight: bold;">SELECT</span> addresses.id <span style="color: #993333; font-weight: bold;">AS</span> id, addresses.email_address <span style="color: #993333; font-weight: bold;">AS</span> email_address, addresses.user_id <span style="color: #993333; font-weight: bold;">AS</span> user_id 
    <span style="color: #993333; font-weight: bold;">FROM</span> addresses <span style="color: #993333; font-weight: bold;">JOIN</span> 
        <span style="color: #66cc66;">&#40;</span><span style="color: #993333; font-weight: bold;">SELECT</span> max<span style="color: #66cc66;">&#40;</span>addresses.id<span style="color: #66cc66;">&#41;</span> <span style="color: #993333; font-weight: bold;">AS</span> maxid <span style="color: #993333; font-weight: bold;">FROM</span> addresses <span style="color: #993333; font-weight: bold;">GROUP</span> <span style="color: #993333; font-weight: bold;">BY</span> addresses.user_id<span style="color: #66cc66;">&#41;</span> <span style="color: #993333; font-weight: bold;">AS</span> max_ids <span style="color: #993333; font-weight: bold;">ON</span> addresses.id = max_ids.maxid 
    <span style="color: #993333; font-weight: bold;">WHERE</span> <span style="color: #993333; font-weight: bold;">NOT</span> <span style="color: #66cc66;">&#40;</span><span style="color: #993333; font-weight: bold;">EXISTS</span> <span style="color: #66cc66;">&#40;</span>
        <span style="color: #993333; font-weight: bold;">SELECT</span> <span style="color: #ff0000;">1</span> <span style="color: #993333; font-weight: bold;">FROM</span> addresses <span style="color: #993333; font-weight: bold;">AS</span> addresses_1 <span style="color: #993333; font-weight: bold;">WHERE</span> addresses.user_id = addresses_1.user_id <span style="color: #993333; font-weight: bold;">AND</span> addresses_1.email_address <span style="color: #993333; font-weight: bold;">LIKE</span> ?
    <span style="color: #66cc66;">&#41;</span><span style="color: #66cc66;">&#41;</span><span style="color: #66cc66;">&#41;</span> <span style="color: #993333; font-weight: bold;">AS</span> anon_1 
<span style="color: #993333; font-weight: bold;">JOIN</span> usertable <span style="color: #993333; font-weight: bold;">ON</span> usertable.id = anon_1.user_id <span style="color: #993333; font-weight: bold;">ORDER</span> <span style="color: #993333; font-weight: bold;">BY</span> anon_1.oid</code></pre>

<p>The important part above is the join condition at the bottom; the <code>join('user')</code> call which would normally produce <code>addresses JOIN usertable ON usertable.id = addresses.user_id</code> was adapted against the <code>aview</code> selectable to produce the ON clause of <code>usertable.id = anon_1.user_id</code>; additionally the <code>ORDER BY</code>, normally <code>ORDER BY addresses.oid</code> was aliased to be <code>ORDER BY anon_1.oid</code>.   </p>

<p>Aliasing like this happens to a more significant degree when we combine eager loading with LIMIT/OFFSET, where the LIMITED query must be wrapped in a selectable which joins against the child table or tables without the limit applied:</p>
<pre class="wp_syntax"><code>&gt;&gt;&gt; <span style="color: #0908ce;font-weight:bold;">print</span> sess.<span style="color: black;">query</span><span style="color: black;">&#40;</span>Address<span style="color: black;">&#41;</span>.<span style="color: black;">options</span><span style="color: black;">&#40;</span>eagerload_all<span style="color: black;">&#40;</span><span style="color: #E04500;">'user.addresses'</span><span style="color: black;">&#41;</span><span style="color: black;">&#41;</span>.<span style="color: black;">limit</span><span style="color: black;">&#40;</span><span style="color: #E04500;">3</span><span style="color: black;">&#41;</span>.<span style="color: #6f0005;">compile</span><span style="color: black;">&#40;</span><span style="color: black;">&#41;</span>
<span style="color: #993333; font-weight: bold;">SELECT</span> 
    anon_1.addresses_id <span style="color: #993333; font-weight: bold;">AS</span> anon_1_addresses_id, 
    anon_1.addresses_email_address <span style="color: #993333; font-weight: bold;">AS</span> anon_1_addresses_email_address, 
    anon_1.addresses_user_id <span style="color: #993333; font-weight: bold;">AS</span> anon_1_addresses_user_id, 
    addresses_1.id <span style="color: #993333; font-weight: bold;">AS</span> addresses_1_id, 
    addresses_1.email_address <span style="color: #993333; font-weight: bold;">AS</span> addresses_1_email_address, 
    addresses_1.user_id <span style="color: #993333; font-weight: bold;">AS</span> addresses_1_user_id, 
    usertable_1.id <span style="color: #993333; font-weight: bold;">AS</span> usertable_1_id, 
    usertable_1.name <span style="color: #993333; font-weight: bold;">AS</span> usertable_1_name 
<span style="color: #993333; font-weight: bold;">FROM</span> <span style="color: #66cc66;">&#40;</span>
    <span style="color: #993333; font-weight: bold;">SELECT</span> 
        addresses.id <span style="color: #993333; font-weight: bold;">AS</span> addresses_id, 
        addresses.email_address <span style="color: #993333; font-weight: bold;">AS</span> addresses_email_address, 
        addresses.user_id <span style="color: #993333; font-weight: bold;">AS</span> addresses_user_id, 
        addresses.oid <span style="color: #993333; font-weight: bold;">AS</span> addresses_oid 
    <span style="color: #993333; font-weight: bold;">FROM</span> addresses <span style="color: #993333; font-weight: bold;">ORDER</span> <span style="color: #993333; font-weight: bold;">BY</span> addresses.oid <span style="color: #993333; font-weight: bold;">LIMIT</span> <span style="color: #ff0000;">3</span> OFFSET <span style="color: #ff0000;">0</span>
    <span style="color: #66cc66;">&#41;</span> <span style="color: #993333; font-weight: bold;">AS</span> anon_1 
    <span style="color: #993333; font-weight: bold;">LEFT</span> <span style="color: #993333; font-weight: bold;">OUTER</span> <span style="color: #993333; font-weight: bold;">JOIN</span> usertable <span style="color: #993333; font-weight: bold;">AS</span> usertable_1 <span style="color: #993333; font-weight: bold;">ON</span> usertable_1.id = anon_1.addresses_user_id 
    <span style="color: #993333; font-weight: bold;">LEFT</span> <span style="color: #993333; font-weight: bold;">OUTER</span> <span style="color: #993333; font-weight: bold;">JOIN</span> addresses <span style="color: #993333; font-weight: bold;">AS</span> addresses_1 <span style="color: #993333; font-weight: bold;">ON</span> usertable_1.id = addresses_1.user_id 
    <span style="color: #993333; font-weight: bold;">ORDER</span> <span style="color: #993333; font-weight: bold;">BY</span> anon_1.oid, usertable_1.oid, addresses_1.oid</code></pre>

<p>To formulate the above query, <code>Query</code> applied these adaptions:</p>

<ul>
<li>The left side of "<code>usertable.id = addresses.user_id</code>" was aliased to become "<code>usertable_1.id = addresses.user_id</code>", to join from the primary table to the <code>users</code> table.</li>
<li>The "<code>usertable.id = addresses.user_id</code>" was aliased in a separate instance to become "<code>usertable_1.id = addresses_1.user_id</code>", to join from the eagerly loaded <code>users</code> to the eagerly loaded child <code>addresses</code>.</li>
<li><p>and,</p>
<pre class="wp_syntax"><code>addresses 
  <span style="color: #993333; font-weight: bold;">LEFT</span> <span style="color: #993333; font-weight: bold;">OUTER</span> <span style="color: #993333; font-weight: bold;">JOIN</span> usertable <span style="color: #993333; font-weight: bold;">AS</span> usertable_1 <span style="color: #993333; font-weight: bold;">ON</span> usertable_1.id = addresses.user_id 
  <span style="color: #993333; font-weight: bold;">LEFT</span> <span style="color: #993333; font-weight: bold;">OUTER</span> <span style="color: #993333; font-weight: bold;">JOIN</span> addresses <span style="color: #993333; font-weight: bold;">AS</span> addresses_1 <span style="color: #993333; font-weight: bold;">ON</span> usertable_1.id = addresses_1.user_id</code></pre>

<p>became (note the full text of <code>anon_1</code>, our LIMITed subquery, in place of <code>addresses</code>):</p>
<pre class="wp_syntax"><code><span style="color: #66cc66;">&#40;</span><span style="color: #993333; font-weight: bold;">SELECT</span> 
addresses.id <span style="color: #993333; font-weight: bold;">AS</span> addresses_id, 
addresses.email_address <span style="color: #993333; font-weight: bold;">AS</span> addresses_email_address, 
addresses.user_id <span style="color: #993333; font-weight: bold;">AS</span> addresses_user_id, 
addresses.oid <span style="color: #993333; font-weight: bold;">AS</span> addresses_oid 
<span style="color: #993333; font-weight: bold;">FROM</span> addresses <span style="color: #993333; font-weight: bold;">ORDER</span> <span style="color: #993333; font-weight: bold;">BY</span> addresses.oid <span style="color: #993333; font-weight: bold;">LIMIT</span> <span style="color: #ff0000;">3</span> OFFSET <span style="color: #ff0000;">0</span><span style="color: #66cc66;">&#41;</span> <span style="color: #993333; font-weight: bold;">AS</span> anon_1 
  <span style="color: #993333; font-weight: bold;">LEFT</span> <span style="color: #993333; font-weight: bold;">OUTER</span> <span style="color: #993333; font-weight: bold;">JOIN</span> usertable <span style="color: #993333; font-weight: bold;">AS</span> usertable_1 <span style="color: #993333; font-weight: bold;">ON</span> usertable_1.id = anon_1.addresses_user_id 
  <span style="color: #993333; font-weight: bold;">LEFT</span> <span style="color: #993333; font-weight: bold;">OUTER</span> <span style="color: #993333; font-weight: bold;">JOIN</span> addresses <span style="color: #993333; font-weight: bold;">AS</span> addresses_1 <span style="color: #993333; font-weight: bold;">ON</span> usertable_1.id = addresses_1.user_id</code></pre>

<p>the final adaption adapted the right side of <code>usertable_1.id=addresses.user_id</code> as well as the left side of the larger join.</p></li>
</ul>

<h3>Column Reduction</h3>

<p>Column reduction means that a collection of columns, such as in the columns clause of a SELECT statement, are reduced to the smallest number of meaningful columns.  Meaningful here means that no column in the collection has a foreign key relationship to any other column in the collection, nor does the selectable have any WHERE criterion that would relate the two columns to be always the same value.   This function is used by the <code>Join</code> construct as well as the ORM to construct the most minimal set of primary key columns for an expression.</p>

<p>Consider the example of "people", "engineers" and "managers".  This is an "inheriting" configuration where "engineers" and "managers" both join to the common information in the "people" table:</p>
<pre class="wp_syntax"><code>&gt;&gt;&gt; people = Table<span style="color: black;">&#40;</span><span style="color: #E04500;">'people'</span>, meta,
...    <span style="color: black;">Column</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'person_id'</span>, Integer, primary_key=<span style="color: #6f0005;">True</span><span style="color: black;">&#41;</span>,
...    <span style="color: black;">Column</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'name'</span>, String<span style="color: black;">&#40;</span><span style="color: #E04500;">50</span><span style="color: black;">&#41;</span><span style="color: black;">&#41;</span>,
...    <span style="color: black;">Column</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'type'</span>, String<span style="color: black;">&#40;</span><span style="color: #E04500;">30</span><span style="color: black;">&#41;</span><span style="color: black;">&#41;</span><span style="color: black;">&#41;</span>
&nbsp;
&gt;&gt;&gt; engineers = Table<span style="color: black;">&#40;</span><span style="color: #E04500;">'engineers'</span>, meta,
...   <span style="color: black;">Column</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'engineer_id'</span>, Integer, ForeignKey<span style="color: black;">&#40;</span><span style="color: #E04500;">'people.person_id'</span><span style="color: black;">&#41;</span>, primary_key=<span style="color: #6f0005;">True</span><span style="color: black;">&#41;</span>,
...   <span style="color: black;">Column</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'engineer_name'</span>, String<span style="color: black;">&#40;</span><span style="color: #E04500;">50</span><span style="color: black;">&#41;</span><span style="color: black;">&#41;</span>,
...   <span style="color: black;">Column</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'primary_language'</span>, String<span style="color: black;">&#40;</span><span style="color: #E04500;">50</span><span style="color: black;">&#41;</span><span style="color: black;">&#41;</span>,
...  <span style="color: black;">&#41;</span>
&nbsp;
&gt;&gt;&gt; managers = Table<span style="color: black;">&#40;</span><span style="color: #E04500;">'managers'</span>, meta,
...   <span style="color: black;">Column</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'manager_id'</span>, Integer, ForeignKey<span style="color: black;">&#40;</span><span style="color: #E04500;">'people.person_id'</span><span style="color: black;">&#41;</span>, primary_key=<span style="color: #6f0005;">True</span><span style="color: black;">&#41;</span>,
...   <span style="color: black;">Column</span><span style="color: black;">&#40;</span><span style="color: #E04500;">'manager_name'</span>, String<span style="color: black;">&#40;</span><span style="color: #E04500;">50</span><span style="color: black;">&#41;</span><span style="color: black;">&#41;</span>
...   <span style="color: black;">&#41;</span></code></pre>

<p>A join which selects all rows from all tables outerjoins both <code>engineers</code> and <code>managers</code> to <code>people</code>:</p>
<pre class="wp_syntax"><code>&gt;&gt;&gt; all_people = people.<span style="color: black;">outerjoin</span><span style="color: black;">&#40;</span>engineers<span style="color: black;">&#41;</span>.<span style="color: black;">outerjoin</span><span style="color: black;">&#40;</span>managers<span style="color: black;">&#41;</span></code></pre>

<p>If we select from this join, we get:</p>
<pre class="wp_syntax"><code>&gt;&gt;&gt; <span style="color: #0908ce;font-weight:bold;">print</span> all_people.<span style="color: #dc143c;">select</span><span style="color: black;">&#40;</span><span style="color: black;">&#41;</span>
<span style="color: #993333; font-weight: bold;">SELECT</span> 
    people.person_id, people.name, people.type, 
    engineers.engineer_id, engineers.engineer_name, engineers.primary_language, 
    managers.manager_id, managers.manager_name 
<span style="color: #993333; font-weight: bold;">FROM</span> people 
    <span style="color: #993333; font-weight: bold;">LEFT</span> <span style="color: #993333; font-weight: bold;">OUTER</span> <span style="color: #993333; font-weight: bold;">JOIN</span> engineers <span style="color: #993333; font-weight: bold;">ON</span> people.person_id = engineers.engineer_id 
    <span style="color: #993333; font-weight: bold;">LEFT</span> <span style="color: #993333; font-weight: bold;">OUTER</span> <span style="color: #993333; font-weight: bold;">JOIN</span> managers <span style="color: #993333; font-weight: bold;">ON</span> people.person_id = managers.manager_id</code></pre>

<p>What's the most minimal primary key we can determine from the above join ?  Rolling up all primary key columns is a little too naive:</p>
<pre class="wp_syntax"><code>&gt;&gt;&gt; <span style="color: #0908ce;font-weight:bold;">print</span> <span style="color: black;">&#91;</span><span style="color: #6f0005;">str</span><span style="color: black;">&#40;</span>c<span style="color: black;">&#41;</span> <span style="color: #0908ce;font-weight:bold;">for</span> c <span style="color: #0908ce;font-weight:bold;">in</span> all_people.<span style="color: black;">c</span> <span style="color: #0908ce;font-weight:bold;">if</span> c.<span style="color: black;">primary_key</span><span style="color: black;">&#93;</span>
<span style="color: black;">&#91;</span><span style="color: #E04500;">'people.person_id'</span>, <span style="color: #E04500;">'engineers.engineer_id'</span>, <span style="color: #E04500;">'managers.manager_id'</span><span style="color: black;">&#93;</span></code></pre>

<p>Because <code>engineer_id</code> and <code>manager_id</code> are always going to have the same value as <code>person_id</code> (or be NULL).  The difference here determines whether we'd need to say  <code>query.get([2,None,2])</code> to load person number 2, or just <code>query.get([2])</code> (note that we don't account for the idea that both <code>engineers</code> and <code>managers</code> might point to the same <code>person_id</code> here, because we are specifically talking about a "joined table inheritance" pattern which does not support "multiple" inheritance).</p>

<p>The <code>reduce_columns()</code> function steps through and gives us just what we want:</p>
<pre class="wp_syntax"><code>&gt;&gt;&gt; <span style="color: #0908ce;font-weight:bold;">from</span> sqlalchemy.<span style="color: black;">sql</span>.<span style="color: black;">util</span> <span style="color: #0908ce;font-weight:bold;">import</span> reduce_columns
&gt;&gt;&gt; <span style="color: #0908ce;font-weight:bold;">print</span> <span style="color: black;">&#91;</span><span style="color: #6f0005;">str</span><span style="color: black;">&#40;</span>c<span style="color: black;">&#41;</span> <span style="color: #0908ce;font-weight:bold;">for</span> c <span style="color: #0908ce;font-weight:bold;">in</span> reduce_columns<span style="color: black;">&#40;</span>
...    <span style="color: black;">&#91;</span>col <span style="color: #0908ce;font-weight:bold;">for</span> col <span style="color: #0908ce;font-weight:bold;">in</span> all_people.<span style="color: black;">c</span> <span style="color: #0908ce;font-weight:bold;">if</span> col.<span style="color: black;">primary_key</span><span style="color: black;">&#93;</span><span style="color: black;">&#41;</span><span style="color: black;">&#93;</span>
<span style="color: black;">&#91;</span><span style="color: #E04500;">'people.person_id'</span><span style="color: black;">&#93;</span></code></pre>

<p><code>reduce_columns()</code> can also do its work given a set of criterion or clauses to use:</p>
<pre class="wp_syntax"><code>&gt;&gt;&gt; s = <span style="color: #dc143c;">select</span><span style="color: black;">&#40;</span><span style="color: black;">&#91;</span>engineers, managers<span style="color: black;">&#93;</span><span style="color: black;">&#41;</span>.\
...   <span style="color: black;">where</span><span style="color: black;">&#40;</span>engineers.<span style="color: black;">c</span>.<span style="color: black;">engineer_name</span>==managers.<span style="color: black;">c</span>.<span style="color: black;">manager_name</span><span style="color: black;">&#41;</span>
&gt;&gt;&gt; <span style="color: #0908ce;font-weight:bold;">print</span> <span style="color: black;">&#91;</span><span style="color: #6f0005;">str</span><span style="color: black;">&#40;</span>c<span style="color: black;">&#41;</span> <span style="color: #0908ce;font-weight:bold;">for</span> c <span style="color: #0908ce;font-weight:bold;">in</span> reduce_columns<span style="color: black;">&#40;</span><span style="color: #6f0005;">list</span><span style="color: black;">&#40;</span>s.<span style="color: black;">c</span><span style="color: black;">&#41;</span>, s<span style="color: black;">&#41;</span><span style="color: black;">&#93;</span>
<span style="color: black;">&#91;</span><span style="color: #E04500;">'engineer_id'</span>, <span style="color: #E04500;">'engineer_name'</span>, <span style="color: #E04500;">'primary_language'</span>, <span style="color: #E04500;">'manager_id'</span><span style="color: black;">&#93;</span></code></pre>

<p>Above, the <code>manager_name</code> column is removed since the WHERE criterion of the select states that they're equivalent.</p>

<p>There's a bunch of other functions, but these three took the longest time to get right (and clause adaption, which has improved massively, still has some ambiguous cases that need to be refined).   So in future posts which talk about "adapting the join" or "translating rows", now you know what I mean.</p>
]]></content:encoded>
			<wfw:commentRss>http://techspot.zzzeek.org/?feed=rss2&amp;p=19</wfw:commentRss>
		</item>
		<item>
		<title>armin on template engines</title>
		<link>http://techspot.zzzeek.org/?p=18</link>
		<comments>http://techspot.zzzeek.org/?p=18#comments</comments>
		<pubDate>Wed, 02 Jan 2008 06:37:53 +0000</pubDate>
		<dc:creator>zzzeek</dc:creator>
		
		<category><![CDATA[templating]]></category>

		<guid isPermaLink="false">http://techspot.zzzeek.org/?p=18</guid>
		<description><![CDATA[Armin Ronacher, who has to be my biggest fan, is a great developer in his own right (and only 18 years old ?  wow....).  Here he is dropping a few ideas on Mako, Genshi and Jinja - while Jinjia is his own Django-like engine, he remains enthusiastic about the other two and uses [...]]]></description>
			<content:encoded><![CDATA[<p><a href="http://lucumr.pocoo.org/">Armin Ronacher</a>, who has to be my biggest fan, is a great developer in his own right (and only 18 years old ?  wow....).  Here he is dropping a few ideas on <a href="http://www.makotemplates.org">Mako</a>, <a href="http://genshi.edgewall.org">Genshi</a> and <a href="http://jinja.pocoo.org/">Jinja</a> - while Jinjia is his own <a href="http://www.djangoproject.com/">Django</a>-like engine, he remains enthusiastic about the other two and <a href="http://lucumr.pocoo.org/cogitations/2008/01/01/python-template-engine-comparison/">uses all three</a>.   What a guy !</p>
]]></content:encoded>
			<wfw:commentRss>http://techspot.zzzeek.org/?feed=rss2&amp;p=18</wfw:commentRss>
		</item>
		<item>
		<title>Revisiting Storm, SQLAlchemy, and Geniusql</title>
		<link>http://techspot.zzzeek.org/?p=17</link>
		<comments>http://techspot.zzzeek.org/?p=17#comments</comments>
		<pubDate>Wed, 26 Dec 2007 20:00:41 +0000</pubDate>
		<dc:creator>zzzeek</dc:creator>
		
		<category><![CDATA[General]]></category>

		<category><![CDATA[SQLAlchemy]]></category>

		<guid isPermaLink="false">http://techspot.zzzeek.org/?p=17</guid>
		<description><![CDATA[We're revisiting Robert Brewer's Storm, SQLAlchemy and Geniusql.  In that post, Robert set up a series of test suites intended to exercise the execution of basic INSERT, UPDATE and SELECT statements, using the established paradigms of each toolkit.  For SQLAlchemy, he used SQLAlchemy's SQL expression language and not its ORM, Geniusql's expression language, [...]]]></description>
			<content:encoded><![CDATA[<p>We're revisiting Robert Brewer's <a href="http://www.aminus.org/blogs/index.php/fumanchu/2007/08/18/storm_sqlalchemy_and_geniusql">Storm, SQLAlchemy and Geniusql</a>.  In that post, Robert set up a series of test suites intended to exercise the execution of basic INSERT, UPDATE and SELECT statements, using the established paradigms of each toolkit.  For SQLAlchemy, he used SQLAlchemy's SQL expression language and not its ORM, Geniusql's expression language, and mostly Storm's ORM except for one or two tests.  The article observes poor performance mostly on the part of SQLAlchemy compared to the other two, and spends lots of time poking at SQLAlchemy stack traces, making various guesses on why we're so slow, and issuing various somewhat damning comments about SA's design.  SQLAlchemy <a href="?p=15">responded</a> immediately with some commentary as well as a new round of speed enhancements in response to some of the "cleanup" items Robert mentioned; but we only focused on SQLAlchemy - we didn't get around to digging deeper into each individual platform's tests and behavior to see what really made them different.   In this post, we've finally done that, and the results are very enlightening.</p>

<p>Robert's results have always seemed strange to SQLAlchemy users since they implied a SQLAlchemy that was almost unusably bloated, which is not observed in the real world. Robert is an experienced developer so I didn't have much doubt, as I'm sure others didn't either, that he was careful in constructing his tests and ensuring that they were working as expected. As a result, SQLAlchemy spent a lot of focus on the SA tests, trying to analyze places where we might be able to become faster.  Nobody, as far as I know, spent any time looking at the other two tests to see why they might be <em>so fast</em>, particularly in the case of Storm where even its <em>ORM</em>, which by definition should be slower than direct SQL constructs, seemed considerably faster than SA's lower level SQL construction language...and curiously, that of Geniusql as well.</p>

<p>It turns out that with just a few minor corrections, even SQLAlchemy's previous 0.3 series comes in second place, slightly slower than Geniusql and usually faster than Storm's ORM (remember that the SQLAlchemy tests are against the lower-level expression language, so they <em>should</em> be faster than an ORM).  For all of Robert's detailed critique of SQLAlchemy's execution and analysis of its "slowness", it's hard to imagine that he made sure to check that both Storm as well as his own Geniusql were also doing what was expected; since a brief look at the actual SQL emitted by each test immediately reveals where most of the extra SQLAlchemy time is being spent - in SQL execution which is plainly not occurring (even though assumed to be) in the case of the other two products.</p>

<p>So to set the record straight (better late than never), I've fixed the tests, modified them to run under a common set of fixtures, and fired up the charts and graphs.  I've added a fourth suite to the tests, a SQLAlchemy ORM test which almost duplicates the Storm ORM test on a line-by-line basis.  The test platform is the MacBook Pro 2.2 Ghz Intel Core Duo, using Python 2.5.1, Postgres 8.2.5, Psycopg2-2.0.6.  SQLAlchemy is trunk r3974 (will be release 0.4.2), Storm version 0.11, and Geniusql r248. The actual speed comparisons between these tools are quite boring.  How boring ?  This boring:</p>

<p><img src="/ssgbenches/total_tests_1_thru_6.png" height="367" /></p>

<p>Where above, Storm runs very fast except for test #4, which as it turns out takes up 78% of the suite's total runtime for the two ORMs.  The ORMs are generally similar in speed and a brief test of Storm's expression language in test #5 is faster than both SQLAlchemy and Geniusql.  Geniusql, which is still alpha and notably does not use any bind parameters, is consistently a little faster than SQLAlchemy EL.</p>

<p>The full test suite and everything else is viewable <a href="/ssgbenches/"><strong>here</strong></a>.  Of note are the <a href="/ssgbenches/sqla.diff"><strong>unified diffs</strong></a> which compare my version of the tests to Robert's originals, as well as a <a href="/ssgbenches/storm_to_sqla_orm.diff"><strong>diff</strong></a> of the Storm ORM test against the new SQLAlchemy ORM test.  I've tried to change as little as possible, and the main structural difference is the common benchmark runner.</p>

<p>So what was happening with Robert's tests ?  Just two main points:</p>

<h3>SQLAlchemy is instructed to issue hundreds of COMMIT statements. Storm is instructed to issue exactly one, Geniusql fails to issue any (even though instructed to).</h3>

<p>Robert relied upon SQLAlchemy's "autocommit" feature for all INSERT and UPDATE statements; a COMMIT is issued to the database after every statement.  Whereas with Storm, he used the ORM which does not "autocommit", you have to call <code>store.commit()</code> explicitly, which he did not.  Additionally, he sets this flag on Geniusql: <code>db.connections.implicit_trans = True</code>, which is meant to instruct Geniusql to issue COMMIT after each INSERT or UPDATE.  But at least in the most current SVN revision of Geniusql, this flag does nothing whatsoever; grepping through PG's SQL logs reveals this. So to compensate for the lack of transactions in the other two test suites, changing the SQLAlchemy engine declaration from this:</p>
<pre class="wp_syntax"><code>db = create_engine<span style="color: black;">&#40;</span>uri<span style="color: black;">&#41;</span></code></pre>

<p>To this:</p>
<pre class="wp_syntax"><code>db = create_engine<span style="color: black;">&#40;</span>uri, strategy=<span style="color: #E04500;">&quot;threadlocal&quot;</span><span style="color: black;">&#41;</span>
db.<span style="color: black;">begin</span><span style="color: black;">&#40;</span><span style="color: black;">&#41;</span></code></pre>

<p>Thus starting a transaction and disabling the COMMIT after each statement,  allows the SQLAlchemy SQL expression test, even using the old version 0.3, to hug very closely to Geniusql's.  This is why SQLAlchemy seemed so slow in the tests which involved issuing INSERTs and UPDATEs. - the overhead of many hundreds of transaction commits within Postgres is profoundly significant.  All the huge amounts of code cleanup and optimizations we've added between 0.3 and the current 0.4 don't approach the time saved by this one small change.</p>

<p>But we're not done yet; another factor was key in the huge graphs posted for test numbers 2 and 3:</p>

<h3>Storm tests two and three issued almost no SQL whatsoever.</h3>

<p>As surprising as this seems, Robert's graph illustrating Storm supposedly executing hundreds of INSERT statements and SELECT statements at unbelievable speeds actually depicts Storm issuing <em>no INSERT or SQL whatsoever</em> in test #2, and <em>no SELECTs whatsoever</em> in test #3.  Let's look:</p>
<pre class="wp_syntax"><code><span style="color: #0908ce;font-weight:bold;">def</span> step_2_insert<span style="color: black;">&#40;</span><span style="color: #6f0005;">self</span><span style="color: black;">&#41;</span>:
    <span style="color: #0908ce;font-weight:bold;">for</span> x <span style="color: #0908ce;font-weight:bold;">in</span> <span style="color: #6f0005;">xrange</span><span style="color: black;">&#40;</span>ITERATIONS<span style="color: black;">&#41;</span>:
        store.<span style="color: black;">add</span><span style="color: black;">&#40;</span>Animal<span style="color: black;">&#40;</span>Species=u<span style="color: #E04500;">'Tick'</span>, Name=u<span style="color: #E04500;">'Tick %d'</span> % x, Legs=<span style="color: #E04500;">8</span><span style="color: black;">&#41;</span><span style="color: black;">&#41;</span></code></pre>

<p>What's missing there ?   Theres no <code>flush()</code> !  Adding a single <code>flush()</code> at the end of the iterations allows the items saved to the store to actually be emitted to the database as INSERT statements:</p>
<pre class="wp_syntax"><code><span style="color: #0908ce;font-weight:bold;">def</span> step_2_insert<span style="color: black;">&#40;</span><span style="color: #6f0005;">self</span><span style="color: black;">&#41;</span>:
    <span style="color: #0908ce;font-weight:bold;">for</span> x <span style="color: #0908ce;font-weight:bold;">in</span> <span style="color: #6f0005;">xrange</span><span style="color: black;">&#40;</span>ITERATIONS<span style="color: black;">&#41;</span>:
        store.<span style="color: black;">add</span><span style="color: black;">&#40;</span>Animal<span style="color: black;">&#40;</span>Species=u<span style="color: #E04500;">'Tick'</span>, Name=u<span style="color: #E04500;">'Tick %d'</span> % x, Legs=<span style="color: #E04500;">8</span><span style="color: black;">&#41;</span><span style="color: black;">&#41;</span>
    store.<span style="color: black;">flush</span><span style="color: black;">&#40;</span><span style="color: black;">&#41;</span></code></pre>

<p>And suddenly the test performs in a believable amount of time, 0.12 seconds for 100 iterations instead of .015.  The reason things seem to "work" without the explicit flush is because Storm issues its 0.12-second flush at the beginning of test #3, so that the data is available for subsequent tests - but because test #3 is meant to take nearly twenty times longer than test #2, this tiny hit at the beginning is unnoticeable, and test #2 gets away with issuing no SQL at all.</p>

<p>For test #3, I have a feeling Robert might have generated his graphs from a more reasonable test, considering that he mentioned using <code>store.find().one()</code>; but as far as what he posted for the actual test, Robert is issuing finds using Storm's ORM, but he's not asserting the results, and he's doing it like this:</p>
<pre class="wp_syntax"><code>WAP = store.<span style="color: black;">find</span><span style="color: black;">&#40;</span>Zoo, Zoo.<span style="color: black;">Name</span>==u<span style="color: #E04500;">'Wild Animal Park'</span><span style="color: black;">&#41;</span></code></pre>

<p>As Robert said, "There must be some things that SQLAlchemy is doing that the others are not."  Indeed - issuing the expected SELECT statements.  The Storm <code>Store</code>, like SQLA's <code>Query</code>, does not evaluate results until called in an iterative context.  So fix as follows:</p>
<pre class="wp_syntax"><code>WAP = <span style="color: #6f0005;">list</span><span style="color: black;">&#40;</span>store.<span style="color: black;">find</span><span style="color: black;">&#40;</span>Zoo, Zoo.<span style="color: black;">Name</span>==u<span style="color: #E04500;">'Wild Animal Park'</span><span style="color: black;">&#41;</span><span style="color: black;">&#41;</span></code></pre>

<p>And once again, the miraculous speed of .02 seconds for 800 full SELECT statements becomes a believable 1.4 seconds.</p>

<p>The actual results for test number two are as follows:</p>

<p><img src="/ssgbenches/step_2_insert.png" height="367" /></p>

<p>A particular thing to note about test #2 is that we are dealing with a total time of less than one second, even for 500 iterations.   Even though you see those four lines diverging, its a horse race around the head of a pin; the differences here are not very important compared to other areas.</p>

<p>For number three:</p>

<p><img src="/ssgbenches/step_3_Properties.png" height="367" /></p>

<p>This test takes considerably longer, and SQLAlchemy's ORM and Storm's are performing very similar operations, as are SQLAlchemy's expression constructs and Geniusql's.</p>

<p>Let's look at test #4 again.  This test involves a battery of about 21 SELECT statements, fully fetched, repeated for a number of iterations; so 100 iterations would be 2100 SELECT statements and result sets fully fetched.</p>

<p><img src="/ssgbenches/step_4_Expressions.png" height="367" /></p>

<p>This is the only test where Storm's ORM can possibly increase its efficiency in fetching; however, you can see that SQLAlchemy's ORM needs to perform a similar amount of work as Storm (we've just optimized the crap out of our ORM fetches in recent versions); fetching ORM-mapped objects is a much more complex operation than fetching rows, as the identity of each row needs to be evaluated, a matching already-loaded object must be searched for, and if not found a new object is instantiated and each of its attributes populated.   SQLAlchemy's SQL constructs perform similarly to Geniusql, and you can be sure that Storm's SQL constructs are similarly fast.</p>

<p>Test #5, "aggregates", issues four SELECT statements for a number of iterations (i.e. 400 for 100 iterations) using the raw SQL constructs of each platform, ORMs included:</p>

<p><img src="/ssgbenches/step_5_Aggregates.png" height="367" /></p>

<p>Storm uses fewer method calls for this operation, but it curiously makes more of a difference in just this test than in other tests where it also has fewer calls.    On that topic, here's a graph of comparative function callcounts, as reported by <code>hotshot</code>, for one iteration in each test:</p>

<p><img src="/ssgbenches/callcounts.png" height="407" width="716" /></p>

<p>This data falls in line with what we'd expect; SQLAlchemy's ORM is more complex than that of Storm and uses more function calls.  The SQL expression language obviously uses less than either ORM in most cases - this graph directly contradicts most of Robert's comments to the effect of "SQLAlchemy (specifically the expression language) is doing much more than the others".  Also interesting is that while Geniusql, a very small toolkit only at rev 248, uses less calls than SQLAlchemy's expression language, the ultimate speeds of both turn out to be somewhat similar in all tests (at least, more similar than their callcounts are different), which implies that the time taken on the database side is a significant factor in speed.</p>

<p>Test number six shows competitive results between all products.  This test loads a record, changes it, and reselects it, then repeats the process.</p>

<p><img src="/ssgbenches/step_6_Editing.png" height="367" /></p>

<p>Storm makes usage here of its ability to issue a quick UPDATE statement and invalidate its ORM cache simultaneously.  SQLAlchemy EL clocks comparably to Storm's optimized operation, whereas SQLAlchemy ORM needs to fall back on a slightly more expensive <code>flush()</code> to update the record in the database and session simultaneously.  To address this, SQLAlchemy will be adding a criterion-based session invalidation feature to its <code>Query</code> object in an upcoming release, possibly 0.4.3.</p>

<p>Robert didn't implement test number seven for the ORM, so the head to head matchup is below.  Nothing too interesting here:</p>

<p><img src="/ssgbenches/step_7_Multiview.png" height="367" /></p>

<p>So admittedly six months too late, I'm hoping this illustrates that there are only slight to moderate differences in performance between these products at a Python execution level. Your app won't grind to a halt with SQLAlchemy nor perform miraculous volumes of SQL in mere milliseconds with Storm or Geniusql - the data Robert illustrated as well as his hypotheses to explain those findings are just  inaccurate.  All the hypothesizing about connection pool slowness and everything else mentioned, while not insignificant, have never created huge performance issues, and we of course continue to optimize and re-simplify all areas of SQLAlchemy on a constant basis (where the "de-simplification" occurs in response to new behaviors and feature improvements which we add all the time).  SQLAlchemy maintains that the best way to get the fastest performance from a database application remains to use the most appropriate SQL at the most appropriate times; exactly the reason why SQLAlchemy has a very rich expression language and SQL compiler, and a highly featured and finely-tunable ORM which improves with every release.</p>
]]></content:encoded>
			<wfw:commentRss>http://techspot.zzzeek.org/?feed=rss2&amp;p=17</wfw:commentRss>
		</item>
		<item>
		<title>SQLAlchemy 0.4.0 Released</title>
		<link>http://techspot.zzzeek.org/?p=16</link>
		<comments>http://techspot.zzzeek.org/?p=16#comments</comments>
		<pubDate>Wed, 17 Oct 2007 22:44:04 +0000</pubDate>
		<dc:creator>zzzeek</dc:creator>
		
		<category><![CDATA[SQLAlchemy]]></category>

		<guid isPermaLink="false">http://techspot.zzzeek.org/?p=16</guid>
		<description><![CDATA[After much development effort and plenty of beta testing, version 0.4 of SQLAlchemy is released.  For those who haven't been following along, this release represents several months of refactorings, rewrites, API reorganizations, and re-documenting of virtually every area of SQLAlchemy's functionality.  A handful of core developers and dozens of contributors have helped this [...]]]></description>
			<content:encoded><![CDATA[<p>After much development effort and plenty of beta testing, version 0.4 of <a href="http://www.sqlalchemy.org">SQLAlchemy</a> is released.  For those who haven't been following along, this release represents several months of refactorings, rewrites, API reorganizations, and re-documenting of virtually every area of SQLAlchemy's functionality.  A handful of core developers and dozens of contributors have helped this release to broadly address many areas, including:
<ul>
    <li>major code simplifications and optimizations within the SQL expression API, execution system, and ORM</li>
    <li>rewritten SQL compiler which allows inlined column defaults, deterministic generation of anonymous alias and label names, unicode identifier support, and dialect-sensitive operator generation; it's also nearly twice as fast</li>
    <li>almost completely rewritten documentation, with two new tutorials.  Check out the new <a href="http://www.sqlalchemy.org/docs/04/intro.html">intro</a>.</li>
    <li>a much more powerful and smart SQL expression API</li>
    <li>a much simplified, consistent, and capable Query object</li>
    <li>high level ORM query operations, such as aliased joins, self-referential joins, operators like any() and has(), without the need for explicit Table/Alias usage</li>
    <li>much better integration of transaction control with ORM sessions</li>
    <li>core ORM support for vertical and horizontal table partitioning across multiple databases</li>
    <li>vastly improved mapper configurations, including a comprehensive collections API, simple polymorphic inheritance configuration, composite datatypes comprised of multiple columns, "dynamic" class attributes which query and filter subsets of large collections</li>
    <li>support for SAVEPOINT and two-phase transactions</li>
    <li>more database support, including Postgres' "UPDATE..RETURNING" syntax, Mysql's "UPDATE..LIMIT" syntax, PG array types, new dialects for Sybase and MS Access</li>
    <li>Ongoing list of whats new at <a href="http://www.sqlalchemy.org/trac/wiki/WhatsNewIn04">WhatsNewIn04</a>.</li>
</ul>
If you haven't looked at SQLAlchemy lately, this is the release to look at...we've really pulled out all the stops on this one.</p>
]]></content:encoded>
			<wfw:commentRss>http://techspot.zzzeek.org/?feed=rss2&amp;p=16</wfw:commentRss>
		</item>
		<item>
		<title>OK.....*more* speed enhancements</title>
		<link>http://techspot.zzzeek.org/?p=15</link>
		<comments>http://techspot.zzzeek.org/?p=15#comments</comments>
		<pubDate>Tue, 21 Aug 2007 01:44:00 +0000</pubDate>
		<dc:creator>zzzeek</dc:creator>
		
		<category><![CDATA[SQLAlchemy]]></category>

		<guid isPermaLink="false">http://techspot.zzzeek.org/?p=15</guid>
		<description><![CDATA[ 

Not satisfied with my last post, Robert Brewer decided to kick me around some more this weekend, posting all kinds of colorful graphs comparing SQLAlchemy's expression compilation and execution speeds to Geniusql and Storm.  Not surprisingly, SA was significantly slower than Geniusql and Storm in most tests except one, despite 0.4 being all [...]]]></description>
			<content:encoded><![CDATA[<p style="float: right"> <iframe src="http://programming.reddit.com/button?t=1&amp;url=http%3A%2F%2Ftechspot.zzzeek.org%2F%3Fp%3D15&amp;" frameborder="0" height="22" scrolling="no" width="130"></iframe></p>

<p>Not satisfied with my last post, Robert Brewer decided to <a href="http://www.aminus.org/blogs/index.php/fumanchu/2007/08/18/storm_sqlalchemy_and_geniusql">kick me around some more</a> this weekend, posting all kinds of colorful graphs comparing SQLAlchemy's expression compilation and execution speeds to Geniusql and Storm.  Not surprisingly, SA was significantly slower than Geniusql and Storm in most tests except one, despite 0.4 being all around way faster than any previous version.</p>

<p>While I haven't looked at Geniusql's source code, I've looked at Storm's; its a far smaller package than SQLAlchemy, and does things in a very simple way.  That's great, and is also a result of it being an in-house product designed to do just what they need and only that (plus, Gustavo's code is really great...too bad he couldn't stick around).  Both products were clearly written with speed in mind from day one, and its clear that Robert is very proud of every execution-related optimization he's made (although the "we don't use bind params" thing I think he's going to need to look at eventually).</p>

<p>On the other hand, I'm more proud of the five-levels deep SQL expressions SQLAlchemy's ORM can come up with for you, if that's what you're asking it for.  Two years ago, SA was the first to bring a really comprehensive version of this idea to the Python world (with Ian's SQLBuilder being the initial inspiration), and inventing all the patterns there was my primary focus.  Now we have other projects doing the same thing, and honoring "the relational model" instead of just "tables" is a given.  Well, if back then our only big idea was just, "we execute <em>so fast</em>!", it probably wouldn't have made much of a splash.  So I think I made the right choice in initial priorities.</p>

<p>Anyway, since Robert keeps poking at me, I went in and cut out some more cruft today.  And just like that, just poking around for slow spots, I cut out  37% more method calls out of the "Insert" speed test in his suite; from 8835 to 5420 in step&#95;1a and from 4825 to 3055 in step&#95;2 running against Postgres.   As well as 43%<strong> </strong>method call reduction in step_6 ("Editing"), from 23473 to 13375.  So he can drop those dark blue lines a little closer to the other two.   As I've said before, there's just a lot of functionality here that takes a lot of time and energy to keep in clean shape.  And I haven't even gotten into adding options to "inline" the execution of sequences and defaults; that's coming up.</p>

<p>As far as the overhead of checking out from the connection pool, Robert showed a damning illustration; his pool checks out in just <em>two function calls</em> where SA is using something like 40.  Well it seemed like what he really meant was, "thats two function calls, <strong>for a connection which is already pulled from the queue and is stored in a dictionary against the current thread</strong>".  Well, thats just plain misleading.  How many function calls does Geniusql use when it <em>does</em> pull from the queue?  Considering we have had an option on our pool since version 0.1 that does <strong>exactly the same thing</strong>, I'm declaring prior art on this idea.  So, I've also reinstated the "thread-localness" of the "contextual" connection which is used for connectionless execution, and cleaned out some more cruft.  Now the SA connection pool uses 21 function calls on a fresh checkout, or just <strong>two function calls</strong>, just like Geniusql, on a thread-local checkout.  Why wasn't it like that already ?  We never profiled, nobody ever complained.  SA tries to do more, has been adding user-requested features for two years, and is little more heavyweight than the latest contenders - but nevertheless, it works just fine for people.  We just don't have anyone complaining about this stuff (please...complain !  It makes us better).  When someone does complain about performance in some area, we fix it (or at least improve as much as we can, and then continue angsting about it for months).</p>

<p>In all honesty, while we aren't a featherlight speed-demon, we perform just fine, and from all accounts remarkably faster than a lot of other ORM tools.  We're not the <a href="http://www.makotemplates.org">Mako</a> of ORMs, we're the <a href="http://genshi.edgewall.org">Genshi</a>.</p>

<p>But now that the dogs are on our tail, and they've got enormous line graphs sprawled across planetpython, seems like we're going to have to just grind code through the profiler just that much more often.</p>

<p><strong>Edit Again: </strong>Oh wow, Robert's latest stack reveals he was testing a never-released development version...at <em>least</em> rev 3248, if not earlier, based on the method names.  So heres another breakdown of individual tests (a unified diff of rev 3248 vs. rev 3388).  Average method reduction is 32%:</p>
<pre class="wp_syntax"><code>==> sa_step_1_create_tables.log <==
-         3128 function calls (3001 primitive calls) in 0.132 CPU seconds
+         2086 function calls (2021 primitive calls) in 0.042 CPU seconds

30%

 ==> sa_step_1a_populate.log <==
-         8835 function calls (8772 primitive calls) in 0.120 CPU seconds
+         5420 function calls (5414 primitive calls) in 0.055 CPU seconds

38%

 ==> sa_step_2_insert.log <==
-         4825 function calls (4795 primitive calls) in 0.044 CPU seconds
+         3055 function calls in 0.030 CPU seconds

36%

 ==> sa_step_3_Properties.log <==
-         48840 function calls (46440 primitive calls) in 0.577 CPU seconds
+         33443 function calls (31203 primitive calls) in 0.284 CPU seconds

31%

 ==> sa_step_4_Expressions.log <==
-         207251 function calls (198931 primitive calls) in 2.458 CPU seconds
+         148381 function calls (140781 primitive calls) in 1.039 CPU seconds

28%

 ==> sa_step_5_Aggregates.log <==
-         18991 function calls (18271 primitive calls) in 0.180 CPU seconds
+         13151 function calls (12561 primitive calls) in 0.123 CPU seconds

30%

 ==> sa_step_6_Editing.log <==
-         23473 function calls (22513 primitive calls) in 0.497 CPU seconds
+         13375 function calls (12535 primitive calls) in 0.117 CPU seconds

43%

 ==> sa_step_7_Multiview.log <==
-         44213 function calls (42403 primitive calls) in 0.464 CPU seconds
+         32001 function calls (30621 primitive calls) in 0.238 CPU seconds

27%</code></pre>
]]></content:encoded>
			<wfw:commentRss>http://techspot.zzzeek.org/?feed=rss2&amp;p=15</wfw:commentRss>
		</item>
		<item>
		<title>Major Speed Enhancements in SQLAlchemy 0.4</title>
		<link>http://techspot.zzzeek.org/?p=14</link>
		<comments>http://techspot.zzzeek.org/?p=14#comments</comments>
		<pubDate>Wed, 15 Aug 2007 01:12:35 +0000</pubDate>
		<dc:creator>zzzeek</dc:creator>
		
		<category><![CDATA[SQLAlchemy]]></category>

		<guid isPermaLink="false">http://techspot.zzzeek.org/?p=14</guid>
		<description><![CDATA[A few weeks ago, Flvio Codeo Coelho posted a comparison of Python database interfaces, with a test that focused primarily on mass insert speed.  While he had good things to say about our performance, I didn't find the results to be very impressive, and not surprisingly - mass insert speed is something we've never [...]]]></description>
			<content:encoded><![CDATA[<p>A few weeks ago, Flvio Codeo Coelho posted a <a href="http://pyinsci.blogspot.com/2007/07/fastest-python-database-interface.html">comparison</a> of Python database interfaces, with a test that focused primarily on mass insert speed.  While he had good things to say about our performance, I didn't find the results to be very impressive, and not surprisingly - mass insert speed is something we've never really focused on.  The idea being, if you have to insert 100,000 records, you'd probably be using a bulk insert tool or raw SQL scripts anyway.</p>

<p>SQLAlchemy's development has historically been focused on the richness of its SQL expression language and the completeness of its  object relational mapper.  While it was important that applications using these features don't use up all the system's memory and grind to a halt, at the same time we've never had a "speed-crazy" mindset.</p>

<p>Contrast this to my other project, <a href="http://www.makotemplates.org">Mako</a>, where speed was the singlemost important priority; every line of code written was checked against a benchmark suite to measure it's impact.  The language itself is pretty barebones, and even a little inconvenient in some ways.   That effort provided a pretty fast product which it's rumored will form the basis of the newly designed <a href="http://www.reddit.com">reddit.com</a>.</p>

<p>But while the "speed at all costs" mindset is very relevant for a template language, it somehow doesn't have the same urgency in the land of SQL, where if people truly want blazing speed, they use raw SQL.  The point of a SQL toolkit and/or an ORM is to enhance the developer experience, to bring richness and ease to common (and not so common) use cases.  Such as, being able to issue SQL statements with Chinese-language identifiers with all the DBAPI-divergent trickery hidden behind the scenes, or more commonly just to have smooth Unicode support, numeric and date consistency, richly featured default generators, support for database-specific features like Oracle OUT parameters and Psycopg2's server-side cursors, a healthy dose of hooks and options for ORM behavior, and everything else.   The sheer volume of behaviors we are shooting to deliver place a burden on the architecture, which constantly has to refactor and adapt in order to accomodate (and SQLAlchemy is nothing if not accommodating).  Not to mention it heavily weighs upon the ability for a small group of unpaid volunteers to get around to reviewing, streamlining, and optimizing all of it.</p>

<p>Nevertheless, the 0.4 release is just plain ginormous (and is currently available as a <a href="http://www.sqlalchemy.org/download.html">beta</a>), and  is changing, streamlining, refactoring just about everything.  We have more users, more developers, more trac tickets, so a lot of what was always just "potential" is finally becoming a reality.  We even have Robert Brewer of <a href="http://projects.amor.org/dejavu/">Dejavu</a> (and of course <a href="http://www.cherrypy.org/">CherryPy</a>) writing benchmark tests for us (although, he might just be trying to get <a href="http://projects.amor.org/geniusql">Geniusql</a> to kick our butt...in the most friendly way of course).  There's a lot of energy right now so I try to get as much production out of that wave as possible while it lasts.</p>

<p>So the particularly egregious slothiness SQLAlchemy exhibited in Flvio's tests (and really, he picked probably the worst thing he could within SA) has been overhauled.   An <a href="http://www.sqlalchemy.org/trac/browser/sqlalchemy/trunk/test/perf/insertspeed.py">adaptation</a> of his test, which cranks it up by not only inserting but also fully selecting the results, inserts and selects 50,000 rows from an in-memory SQLite database.  When run against 0.3, Hotspot shows this extremely large number of function calls:</p>
<pre class="wp_syntax"><code>2850532 function calls (2850529 primitive calls) in 19.501 CPU seconds</code></pre>

<p>That's really bad.  In 0.4 trunk, we have it down to this:</p>
<pre class="wp_syntax"><code>900525 function calls (900513 primitive calls) in 8.128 CPU seconds</code></pre>

<p>That's <em>68% fewer</em> function calls to insert and iterate 50,000 rows of three columns each. It's not that the new system is all that blazingly fast; a raw insert of 100,000 rows with SQLite takes 4 seconds on my machine, while with SA takes 14 seconds.  Still, that's a whole lot better than 0.3 which takes 32 seconds.  Speedups like this are not due to any brilliant re-architecting, it's just having enough people helping out such that we have the resources to address these old, crufty functionalities that got written at 2:30 AM eight months ago.</p>

<p>For everything that gets said about SQLAlchemy, we are really just barely out of the "idea" phase, and it was meant to take a long time for this thing to be really great; especially at "homegrown" pace.   Our version number being only 40% of 1.0 is quite intentional.</p>
]]></content:encoded>
			<wfw:commentRss>http://techspot.zzzeek.org/?feed=rss2&amp;p=14</wfw:commentRss>
		</item>
	</channel>
</rss>
